# План по улучшению книги «Файлы: missing manual»

Этот файл содержит список идей, дополнений и исправлений для улучшения содержания книги.

## 1. Общие улучшения (Project-wide)
- [ ] **Секции «Troubleshooting»**: Добавить в конец каждой части (или ключевых глав) блок с разбором типичных проблем (например, "Zombie files", ошибки кодировки в терминале, "Disk full" при наличии места).
- [ ] **Мета-информация о книге**: Обновить `about.md` и `index.md`:
    - Указать, что книга разрабатывается при содействии моделей ИИ (Gemini 3, Claude 4.5).
    - Добавить дисклеймер о возможных ошибках и необходимости проверки фактов (hallucinations risk).
    - Явно пригласить читателей присылать улучшения и исправления (через email или PR).
- [ ] **Безопасность (Data at Rest)**: Добавить сводную информацию или отдельную главу про шифрование (LUKS, BitLocker, FileVault, VeraCrypt).
- [ ] **Визуализация**: Добавить больше схем Mermaid для архитектурных уровней (VFS, сетевые протоколы, путь байта от диска до приложения).
- [ ] **Упражнения и практические задания**: Добавить в конец каждой части блок «Попробуйте сами» с 3–5 заданиями возрастающей сложности (исследовательские + кодинг).
- [ ] **Гиперссылки в глоссарии**: Заменить plain-text ссылки «→ Глава N» на кликабельные Markdown-ссылки. Проверить полноту: все ключевые термины из глав должны быть представлены.
- [ ] **Единообразие двуязычных терминов в глоссарии**: Часть терминов дана с русским переводом в скобках, часть — без. Привести к единому формату.
- [ ] **Исправление нумерации глав на index.md**: Таблица на главной странице указывает «Главы 34–46» для Части V, но реально глав 34–50. Синхронизировать.
- [ ] **Changelog / версионирование**: Добавить страницу «Что нового» с датированными записями об изменениях (или секцию в about.md).
- [ ] **Расширение about.md**: Добавить краткую биографию автора, технический стек проекта (MkDocs Material, GitHub Pages), раздел «Как внести вклад» (contributing guide).

## 2. Часть I. Файлы как элемент файловой системы
- [ ] **Таблица лимитов ФС**: Сравнение макс. размера файла и тома для ext4, XFS, NTFS, APFS, exFAT, FAT32.
- [ ] **File Locking**: Добавить детали про механизмы блокировок (advisory vs mandatory, `flock`, `fcntl`). Почему базы данных не любят NFS?
- [ ] **Бинарные исполняемые файлы**: Краткий обзор структур ELF (Linux) и Mach-O (macOS) в контексте «файл как контейнер кода/данных».
- [ ] **Extended Attributes (xattr)**: Расширить примеры использования (например, карантин в macOS или метаданные в SELinux).
- [ ] **Memory-Mapped Files (mmap)**: Добавить в главу о дескрипторах или файловых операциях раздел о mmap — проецирование файла в память, когда это эффективнее read/write, подводные камни (coherence, truncation).
- [ ] **Filesystem Events / Watches**: inotify (Linux), FSEvents (macOS), ReadDirectoryChangesW (Windows) — как программы узнают об изменениях файлов в реальном времени. Практика: наблюдение за директорией на Python (`watchdog`).
- [ ] **Атомарность файловых операций**: Паттерн «write to temp + rename» для безопасной записи. Почему `rename()` атомарен в пределах одной ФС, а дозапись — нет. fsync и его важность.
- [ ] **Временные файлы**: `tempfile` (Python), `mktemp` (shell), `/tmp` vs `/var/tmp`. Автоочистка, безопасность (race condition при предсказуемых именах).

## 3. Часть II. Файлы как контейнеры данных
- [ ] **Визуализация Endianness**: Схема размещения байт в памяти для Little и Big Endian. Примеры форматов, где это критично.
- [ ] **Zero-copy**: Объяснение концепции передачи данных без копирования в памяти (sendfile, splice) — почему это делает веб-серверы быстрыми.
- [ ] **SIMD и кодировки**: Упомянуть, как современные процессоры используют векторные инструкции для ускорения валидации UTF-8.
- [ ] **BOM в реальном мире**: Практические проблемы с BOM (Byte Order Mark) — конфликты с шебангом, JSON-парсерами, Git diff. Как обнаружить и удалить BOM.

## 4. Часть III. Форматы файлов
- [ ] **Бинарные альтернативы JSON**: Краткий обзор MessagePack, CBOR, BSON. Когда стоит переходить с JSON на бинарный формат.
- [ ] **SQLite — файл как база данных**: Глубокий разбор формата файла SQLite, ACID, страницы, журнал (WAL). Почему это лучший формат для хранения структурированных данных в одном файле.
- [ ] **Parquet Internals**: Описать Predicate Pushdown и Row Groups (почему чтение 1 колонки из 100 работает мгновенно).
- [ ] **Schema Registry**: Упомянуть в контексте Avro и Kafka — управление жизненным циклом схем вне самого файла.
- [ ] **Таблица-навигатор «Какой формат выбрать»**: Decision matrix: человекочитаемость, размер, скорость парсинга, поддержка схемы, streaming-совместимость. Помогает читателю не теряться в 10+ форматах.
- [ ] **JSON Schema и валидация**: Как описывать и проверять структуру JSON-документов. Аналогии с XSD для XML.
- [ ] **Формат SQLite WAL подробнее**: Добавить схему страниц и журнала, показать `sqlite3_analyzer` для исследования реального файла.

## 5. Часть IV. Работа с файлами и потоками
- [ ] **Python: Durable mappings**: Модули `dbm` и `shelve`. Когда нужно простое хранилище «ключ-значение» без полноценной инфраструктуры БД.
- [ ] **DuckDB + S3**: Добавить пример запроса к удаленному Parquet-файлу по HTTP/S3 без полного скачивания (HTTP Range Requests).
- [ ] **Обновление списка инструментов**: Добавить `uv` (Python), `dust` (анализ места), `tokei` (статистика кода), `hexyl` (hex-просмотрщик).
- [ ] **io_uring**: Упомянуть как современную альтернативу стандартному асинхронному I/O в Linux.
- [ ] **Бенчмарки форматов**: Практическое сравнение скорости чтения/записи + размера для CSV vs JSON vs Parquet vs SQLite на одном датасете. Код на Python + DuckDB, воспроизводимый читателем.
- [ ] **Pipe и FIFO в деталях**: Именованные каналы (mkfifo), размер буфера pipe, deadlock при полном буфере. Практика: обмен данными между процессами через FIFO.

## 6. Часть V. Инфраструктура хранения
- [ ] **Глубокий разбор APFS**: Контейнеры (Containers), клоны файлов (Clones) и мгновенные снимки (Snapshots). Чем отличается от традиционных ФС.
- [ ] **Безопасность SSD**: Почему `shred` бесполезен на SSD и как работает Secure Erase (`blkdiscard` / NVMe Format).
- [ ] **Cloud-native storage**: Signed URLs и Lifecycle Policies в S3. Особенности S3-совместимых хранилищ (MinIO).
- [ ] **Git Internals**: Дополнить главу 47 схемой того, как Git хранит объекты (blobs, trees, commits).
- [ ] **Переписать введение Части V (ch5/00-intro.md)**: Текущее введение — самое слабое из всех частей. Нужно: исправить заголовок («часть» вместо «глава»), добавить таблицу глав с ссылками (17 глав!), Mermaid-диаграмму архитектурных слоёв, блок `!!! abstract`.
- [ ] **FUSE — файловые системы в user-space**: Добавить раздел про FUSE (sshfs, rclone mount, s3fs). Как создать простейшую ФС на Python (`fusepy`).
- [ ] **Сравнительная таблица файловых систем**: ext4 vs XFS vs Btrfs vs ZFS vs APFS vs NTFS — CoW, снапшоты, макс. размер, журналирование, компрессия, дедупликация.
- [ ] **tmpfs и ramfs**: Файловые системы в оперативной памяти — зачем нужны, чем отличаются друг от друга, типичные точки монтирования (`/dev/shm`, `/tmp`, `/run`). Применение: ускорение сборок, хранение секретов без записи на диск, shared memory между процессами. Аналоги на macOS (RAM-диск через `diskutil`).

## 7. Исправления и техдолг
- [ ] **Синхронизация нумерации глав**: `index.md` показывает «Главы 34–46» для Части V, но реально 34–50. Обновить таблицу.
- [ ] **Проверка ссылок**: Запустить `mkdocs build --strict` и исправить все broken links (например, ссылка на Глоссарий из ch0/00-intro.md).
