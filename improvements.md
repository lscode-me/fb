# План по улучшению книги «Файлы: missing manual»

Этот файл содержит список идей, дополнений и исправлений для улучшения содержания книги.

## 1. Общие улучшения (Project-wide)
- [ ] **Секции «Troubleshooting»**: Добавить в конец каждой части (или ключевых глав) блок с разбором типичных проблем (например, "Zombie files", ошибки кодировки в терминале, "Disk full" при наличии места).
- [ ] **Мета-информация о книге**: Обновить `about.md` и `index.md`:
    - Указать, что книга разрабатывается при содействии моделей ИИ (Gemini 3, Claude 4.5).
    - Добавить дисклеймер о возможных ошибках и необходимости проверки фактов (hallucinations risk).
    - Явно пригласить читателей присылать улучшения и исправления (через email или PR).
- [ ] **Безопасность (Data at Rest)**: Добавить сводную информацию или отдельную главу про шифрование (LUKS, BitLocker, FileVault, VeraCrypt).
- [ ] **Визуализация**: Добавить больше схем Mermaid для архитектурных уровней (VFS, сетевые протоколы, путь байта от диска до приложения).

## 2. Часть I. Файлы как элемент файловой системы
- [ ] **Таблица лимитов ФС**: Сравнение макс. размера файла и тома для ext4, XFS, NTFS, APFS, exFAT, FAT32.
- [ ] **File Locking**: Добавить детали про механизмы блокировок (advisory vs mandatory, `flock`, `fcntl`). Почему базы данных не любят NFS?
- [ ] **Бинарные исполняемые файлы**: Краткий обзор структур ELF (Linux) и Mach-O (macOS) в контексте «файл как контейнер кода/данных».
- [ ] **Extended Attributes (xattr)**: Расширить примеры использования (например, карантин в macOS или метаданные в SELinux).

## 3. Часть II. Файлы как контейнеры данных
- [ ] **Визуализация Endianness**: Схема размещения байт в памяти для Little и Big Endian. Примеры форматов, где это критично.
- [ ] **Zero-copy**: Объяснение концепции передачи данных без копирования в памяти (sendfile, splice) — почему это делает веб-серверы быстрыми.
- [ ] **SIMD и кодировки**: Упомянуть, как современные процессоры используют векторные инструкции для ускорения валидации UTF-8.

## 4. Часть III. Форматы файлов
- [ ] **Бинарные альтернативы JSON**: Краткий обзор MessagePack, CBOR, BSON. Когда стоит переходить с JSON на бинарный формат.
- [ ] **SQLite — файл как база данных**: Глубокий разбор формата файла SQLite, ACID, страницы, журнал (WAL). Почему это лучший формат для хранения структурированных данных в одном файле.
- [ ] **Parquet Internals**: Описати Predicate Pushdown и Row Groups (почему чтение 1 колонки из 100 работает мгновенно).
- [ ] **Schema Registry**: Упомянуть в контексте Avro и Kafka — управление жизненным циклом схем вне самого файла.

## 5. Часть IV. Работа с файлами и потоками
- [ ] **Python: Durable mappings**: Модули `dbm` и `shelve`. Когда нужно простое хранилище «ключ-значение» без полноценной инфраструктуры БД.
- [ ] **DuckDB + S3**: Добавить пример запроса к удаленному Parquet-файлу по HTTP/S3 без полного скачивания (HTTP Range Requests).
- [ ] **Обновление списка инструментов**: Добавить `uv` (Python), `dust` (анализ места), `tokei` (статистика кода), `hexyl` (hex-просмотрщик).
- [ ] **io_uring**: Упомянуть как современную альтернативу стандартному асинхронному I/O в Linux.

## 6. Часть V. Инфраструктура хранения
- [ ] **Глубокий разбор APFS**: Контейнеры (Containers), клоны файлов (Clones) и мгновенные снимки (Snapshots). Чем отличается от традиционных ФС.
- [ ] **Безопасность SSD**: Почему `shred` бесполезен на SSD и как работает Secure Erase (`blkdiscard` / NVMe Format).
- [ ] **Cloud-native storage**: Signed URLs и Lifecycle Policies в S3. Особенности S3-совместимых хранилищ (MinIO).
- [ ] **Git Internals**: Дополнить главу 47 схемой того, как Git хранит объекты (blobs, trees, commits).
