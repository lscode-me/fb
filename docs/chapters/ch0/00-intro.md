# О книге

## Эволюция понятия "файл"

### До файлов: перфокарты и магнитные ленты

Понятие «файл» кажется настолько естественным, что трудно представить время, когда его не было. Но первые компьютеры (1940–50-е) **не имели файлов вообще**. Программы и данные хранились на **перфокартах** — стопках картонных карточек с пробитыми отверстиями. Каждая карточка — 80 колонок, одна строка кода. Программы буквально «несли в руках» и передавали оператору.

Магнитные ленты (1950-е) улучшили ситуацию — данные стали записываться последовательно на катушки. Но доступ оставался **строго последовательным**: чтобы прочитать запись в конце ленты, нужно было промотать всё с начала. Именно записи на лентах впервые стали называть **файлами** (от англ. *file* — подшивка документов).

Всё изменилось с появлением **магнитных дисков** (IBM 305 RAMAC, 1956) — они дали **произвольный доступ** к данным. А первая система, где пользователи работали с файлами в привычном нам смысле — с именами, каталогами и правами — стала **CTSS** (Compatible Time-Sharing System, MIT, 1961). Оттуда концепция перешла в **Multics** (1965), а из Multics — в **Unix** (1969), который сделал файл центральной абстракцией всей операционной системы.

### Когда файлы были для всех

В 1980-х, 1990-х и начале 2000-х годов понятие **файла** было универсальным языком между человеком и компьютером. Пользователь MS-DOS набирал `DIR` и видел список файлов. Пользователь Windows перетаскивал иконки документов между папками. Все знали, что такое `README.TXT`, `AUTOEXEC.BAT` или `CONFIG.SYS`. Файл был **осязаемой** сущностью: у него было имя, расширение (`.doc`, `.jpg`, `.exe`), размер в килобайтах, дата создания.

Пользователи разбирались в программах-архиваторах (ARJ, WinRAR), понимали разницу между текстовым файлом и бинарным, знали, что `.bmp` занимает много места, а `.jpg` — сжатый формат. Коллекции MP3 занимали гигабайты на жёстких дисках, и каждый знал, что 128 kbps — это среднее качество, а 320 kbps — почти как CD. Файловые менеджеры (Norton Commander, Total Commander, Far Manager, Windows Explorer) были центром работы с компьютером.

### Абстракция поглотила файлы

С конца 2000-х и особенно в 2010-х годах ситуация начала стремительно меняться:

- **Смартфоны и планшеты** (iOS, Android) — пользователи работают с **приложениями** и **документами**, но не с файлами напрямую
- **Облачные сервисы** (Google Docs, Dropbox, iCloud) — документы живут "где-то там", синхронизируются автоматически
- **Стриминг вместо файлов** — MP3-коллекции уступили место Spotify и Apple Music; фильмы в `.avi` и `.mkv` заменил Netflix. Целое поколение выросло, не зная, что музыку можно "скачать"
- **Медиатеки** (Photos, Google Photos) — фото управляются через библиотеки, а не через файловую систему
- **App Stores** — установка программ через магазины, а не через скачивание `.exe` или `.dmg` файлов

Современный пользователь iPhone может годами пользоваться устройством и **ни разу не столкнуться с понятием "файл"**. Он работает с фотографиями в приложении Photos, с документами в Pages, с музыкой в Apple Music. Файловая система скрыта за слоями абстракции.

!!! quote "Стив Джобс, 2010"
    "Пользователям не нужна файловая система. Это пережиток прошлого. Им нужны их документы, фотографии и музыка — и они должны быть доступны везде."

### Файлы остались профессионалам

Сегодня с файлами напрямую работают:

- **Разработчики** — пишут код в `.py`, `.js`, `.go` файлах, собирают проекты, управляют зависимостями
- **Системные администраторы** — настраивают конфигурационные файлы, анализируют логи, управляют правами доступа
- **Data Engineers** — обрабатывают терабайты данных в `.csv`, `.parquet`, `.json` форматах
- **DevOps инженеры** — пишут скрипты, создают Docker образы, управляют инфраструктурой как кодом

Термин **"файл"** стал профессиональным жаргоном. Но парадокс в том, что даже профессионалы часто имеют **поверхностное понимание** файлов.

## Мотивация: зачем эта книга?

### Интуиция vs глубокое понимание

Большинство инженеров владеют **базовым интуитивным** понятием файла:

- ✅ "Файл — это данные на диске с именем"
- ✅ "Можно создать, прочитать, изменить, удалить"
- ✅ "Есть текстовые и бинарные файлы"

Но при этом возникают **пробелы в понимании**:

#### Пробел 1: Что определяет тип файла?
- В чём разница между `.jpg`, `.png` и `.bmp`? Почему нельзя просто переименовать `.txt` в `.csv` и ожидать, что всё заработает?
- Что внутри `.exe` и чем он отличается от `.py` скрипта?
- Почему один и тот же файл может открываться в разных программах по-разному?
- Как система определяет, чем открыть файл — по расширению или по содержимому?

#### Пробел 2: Кодировки — вечный источник боли
- Почему русский текст превращается в "кракозябры" при открытии?
- В чём разница между ASCII, CP1251, UTF-8 и почему это важно?
- Почему файл, созданный на Windows, может сломаться на Linux (и наоборот)?
- Что такое BOM и почему он ломает скрипты?
- Почему `len("привет")` и размер файла с этим словом — разные числа?

#### Пробел 3: Файлы между операционными системами
- Почему скрипт, написанный на Windows, падает на Linux с ошибкой?
- Что такое `\r\n` vs `\n` и почему это до сих пор проблема?
- Почему путь `C:\Users\file.txt` не работает на macOS?
- Чем отличаются права доступа к файлам на Unix и Windows?

#### Пробел 4: Что происходит при работе с файлами?
- Почему удалили файл, а место на диске не освободилось?
- Что произойдёт, если два процесса пишут в один файл одновременно?
- Почему `du` и `ls -l` показывают разный размер?
- Почему копирование миллиона маленьких файлов медленнее, чем одного большого?

#### Пробел 5: Хранение и инфраструктура
- В чём разница между файлом и blob в S3?
- Что такое object storage и чем оно отличается от файловой системы?
- Что такое жёсткие и символические ссылки и зачем они нужны?
- Когда использовать файлы, а когда — базу данных или объектное хранилище?

### Практические последствия пробелов

Непонимание файлов приводит к реальным проблемам:

**Кракозябры вместо текста:**
```python
# Файл создан на Windows в CP1251, открываем на Linux
>>> open('report.csv').read()
'\xc2\xe0\xeb\xfe\xf2\xe0'  # мусор вместо "Валюта"

# Нужно явно указать кодировку
>>> open('report.csv', encoding='cp1251').read()
'Валюта'
```

**Скрипт работает на macOS, падает на Linux:**
```bash
# Файл deploy.sh создан на Windows, содержит \r\n
$ bash deploy.sh
/bin/bash: bad interpreter: No such file or directory

# Причина — невидимый символ \r в конце строк
$ cat -A deploy.sh
#!/bin/bash^M$    # ^M — это \r
```

**Удалили файл, а место не освободилось:**
```bash
# Приложение держит открытый дескриптор на лог-файл
$ ls -lh /var/log/app.log
-rw-r--r-- 1 root root 5.0G ...

$ rm /var/log/app.log
$ df -h /var  # место не освободилось!

# Потому что процесс всё ещё пишет в удалённый файл
$ lsof | grep deleted
app  12345  root  3w  REG  8,1  5368709120  (deleted)

# Решение: перезапустить процесс или truncate дескриптор
```

**Два процесса пишут в один файл — данные перемешались:**
```python
# worker_1.py и worker_2.py пишут в results.csv
with open('results.csv', 'a') as f:
    f.write(f'{timestamp},{value}\n')  # гонка записи!

# Результат: строки наложились друг на друга
# 2025-01-15,42.02025-01-15,17.3
#                 ^-- данные склеились
```

**Сравнение файлов, которые "одинаковые", но нет:**
```bash
# Файлы выглядят идентично, но diff находит различия
$ diff file_unix.txt file_windows.txt
# Разница только в окончаниях строк: \n vs \r\n

$ xxd file_windows.txt | head -1
00000000: 4865 6c6c 6f0d 0a    Hello..    # 0d 0a = \r\n
$ xxd file_unix.txt | head -1
00000000: 4865 6c6c 6f0a       Hello.     # 0a = \n
```

## О чём эта книга

Эта книга — **missing manual** про файлы. Мы заполним пробелы и построим **целостное понимание** файлов на трёх уровнях:

### Часть I. Файлы как элемент файловой системы (Chapters 1–9)
- Что такое файл с точки зрения операционной системы
- Метаданные, inode, права доступа, дескрипторы
- Ссылки, пути, расширенные атрибуты, ACL
- **Везде, где уместно, сравниваем Unix/Linux и Windows**

### Часть II. Файлы как контейнеры данных (Chapters 10–15)
- Иерархия представлений: байты → структуры → семантика
- От бинарных данных к тексту: ASCII, кодировки, Unicode, UTF-8

### Часть III. Форматы файлов (Chapters 16–25)
- Текстовые форматы: JSON, YAML, TOML, CSV, XML
- Бинарные форматы: Protobuf, Parquet, архивы, медиа

### Часть IV. Работа с файлами (Chapters 26–33)
- Инструменты: от `cat` и `grep` до DuckDB и jq
- Практические примеры на Linux и Python

### Часть V. Инфраструктура хранения (Chapters 34–50)
- Архитектура накопителей, файловые системы, сетевое и облачное хранение

## Для кого эта книга

- **Начинающие разработчики** — систематизируете знания о файлах
- **Data Engineers** — поймёте форматы данных и инструменты обработки
- **Системные администраторы** — углубите понимание файловых систем
- **DevOps инженеры** — научитесь эффективно работать с файлами в автоматизации

!!! tip "Как читать"
    Главы можно читать последовательно или выборочно. Если вас интересуют конкретные темы:
    
    - **Кодировки и Unicode** → Главы 12–14
    - **Работа с CSV/JSON в Python** → Главы 16, 19
    - **Современные инструменты (DuckDB, jq, miller)** → Главы 32–33
    - **Устройство файловых систем** → Главы 34–43

## Соглашения

### Операционные системы
Мы рассматриваем **Unix/Linux и Windows** параллельно, отмечая различия там, где это важно:

!!! example "Пример: пути к файлам"
    **Unix/Linux:**
    ```bash
    /home/user/documents/file.txt
    ```
    
    **Windows:**
    ```
    C:\Users\User\Documents\file.txt
    ```

### Примеры кода
Все примеры **работающие** и проверены. Используем:

- **Bash** для примеров командной строки (Linux/macOS)
- **PowerShell** для Windows (где уместно)
- **Python 3.9+** для программных примеров

### Терминология
При первом упоминании термина даём **определение** и **пример**. Все ключевые термины собраны в [Глоссарии](../../glossary.md).

---

Теперь, когда мы понимаем **зачем** нужна эта книга, давайте начнём с основ — что такое файл как элемент файловой системы.

!!! tip "Следующая глава"
    → [Глава 1. Что такое файл](../ch1/01-file-definition.md)
