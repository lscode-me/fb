---
title: Что такое файл в Unix/Linux — философия "Everything is a file"
description: Узнайте, что такое файл в Unix и Linux. Философия "Everything is a file", единый интерфейс open/read/write/close, файловые дескрипторы и типы файлов.
---

# Глава 1. Что такое файл: формальное определение

## Введение

Что общего между текстовым документом, каталогом, жёстким диском и сетевым соединением? В Unix — всё это **файлы**.

## 1.1 «Everything is a file» — философия Unix

Одна из главных идей Unix, заложенная Кеном Томпсоном и Деннисом Ритчи в 1970-х, — **всё является файлом** (everything is a file). Любой ресурс в системе — данные на диске, каталог, устройство, сетевое соединение — представлен как файл и доступен через **единый интерфейс**:

```
open()  → получить доступ к ресурсу
read()  → прочитать данные
write() → записать данные
close() → освободить ресурс
```

Почему это важно? Потому что программе **не нужно знать**, куда именно она пишет данные. Один и тот же код работает с текстовым файлом, с терминалом, с сетевым сокетом:

```bash
# Записать строку в обычный файл
$ echo "hello" > file.txt

# Записать строку в терминал (символьное устройство)
$ echo "hello" > /dev/tty

# Записать строку в «чёрную дыру» (псевдоустройство)
$ echo "hello" > /dev/null

# Во всех случаях работает одна и та же операция: write()
```

Эта унификация — не случайность. Если каталог — это тоже файл (специальный файл, содержащий список имён и ссылок на другие файлы), то к нему применимы те же операции: `open()`, `read()` (получить список содержимого), `close()`. Если устройство — файл, то для чтения с диска не нужен отдельный API: достаточно `open("/dev/sda")` и `read()`. Это радикально упрощает и программирование, и системное администрирование.

Вот несколько примеров, которые показывают мощь этого подхода:

```bash
# Создать ISO-образ с CD-ROM — просто скопировать «файл» устройства
$ dd if=/dev/cdrom of=backup.iso
# CD-ROM — файл, ISO — файл. Одна команда.

# Полный бэкап жёсткого диска (побайтовая копия)
$ dd if=/dev/sda of=/backup/disk.img bs=4M
# Весь диск с разделами, загрузчиком, данными — один файл

# Восстановить диск из бэкапа — просто запись в обратную сторону
$ dd if=/backup/disk.img of=/dev/sda bs=4M

# Посмотреть, что отправляет мышь (поток байт с устройства)
$ cat /dev/input/mouse0 | xxd | head
# Двигаем мышь — видим байты координат и кликов

# Генерировать случайный пароль из «файла» случайных данных
$ head -c 32 /dev/urandom | base64
# K8f3mZx7Q2pN1vR...

# Узнать температуру CPU, прочитав «файл»
$ cat /sys/class/thermal/thermal_zone0/temp
47000   # 47.0°C

# Отправить данные на принтер — записать в файл устройства
$ cat document.ps > /dev/usb/lp0

# Записать нули на диск (безопасное стирание)
$ dd if=/dev/zero of=/dev/sda bs=1M
```

Ни одна из этих операций не требует специального API. Всё работает через `read()` и `write()`, потому что в Unix диск, CD-ROM, мышь, датчик температуры и генератор случайных чисел — это файлы.

!!! quote "Деннис Ритчи"
    «Одна из самых красивых идей Unix — это унифицированная модель ввода-вывода. Открыть, прочитать, записать, закрыть — четыре операции для всего.»

Именно из-за этой философии в Unix появилось **7 типов файлов** — потому что каждый ресурс системы представлен файловым интерфейсом.

## 1.2 Формальное определение файла

**Определение**:
> **Файл** (file) — это именованный объект файловой системы, доступный через стандартный интерфейс ввода-вывода.

В **узком** смысле (обычный файл) — это именованная область данных на носителе. В **широком** смысле (философия Unix) — это любой ресурс, доступный через файловый интерфейс.

Обычный файл состоит из трёх компонентов:

1. **Имя** (filename) — идентификатор для пользователя и программ (до 255 байт в большинстве Unix ФС)
2. **Данные** (data) — содержимое файла (может быть пустым, от 0 байт до 16 ТБ в ext4)
3. **Метаданные** (metadata) — информация *о* файле (размер, права, даты, владелец)

!!! note "Важно"
    Даже пустой файл (0 байт данных) имеет метаданные и занимает место в файловой системе. Имя файла — это запись в каталоге, а метаданные хранятся в отдельной структуре (inode в Unix, MFT record в Windows).

## 1.3 Типы файлов в Unix

Раз «всё — файл», нужно различать **виды** файлов. В Unix-подобных системах их 7:

| Тип | Описание | Пример | Зачем нужен файловый интерфейс |
|-----|----------|--------|-------------------------------|
| **Обычный файл** | Данные на диске | `document.txt` | Хранение и обработка данных |
| **Директория** | Список имён → inode | `/home/user/` | Навигация, организация |
| **Символическая ссылка** | Путь к другому файлу | `link → target` | Алиасы, версионирование |
| **Блочное устройство** | Доступ к диску блоками | `/dev/sda` | Чтение/запись на диск тем же `read()`/`write()` |
| **Символьное устройство** | Побайтовый доступ | `/dev/tty` | Терминалы, порты, `/dev/null` |
| **Named pipe (FIFO)** | Однонаправленный канал | `/tmp/mypipe` | Передача данных между процессами |
| **Сокет** | Двунаправленный канал | `/var/run/docker.sock` | Сетевое и локальное IPC |

## 1.4 Типы файлов в Unix/Linux/BSD на практике

Тип файла определяется первым символом в выводе `ls -l`:

=== "Linux"

    ```bash
    $ ls -l
    -rw-r--r--  1 user group  1024 Feb  4 10:00 file.txt       # - regular file
    drwxr-xr-x  2 user group  4096 Feb  4 10:00 directory/     # d directory
    lrwxrwxrwx  1 user group    10 Feb  4 10:00 link -> file   # l symbolic link
    brw-rw----  1 root disk   8, 0 Feb  4 10:00 /dev/sda       # b block device
    crw-rw-rw-  1 root tty    5, 0 Feb  4 10:00 /dev/tty       # c character device
    prw-r--r--  1 user group     0 Feb  4 10:00 mypipe         # p named pipe (FIFO)
    srwxrwxrwx  1 user group     0 Feb  4 10:00 socket         # s socket
    ```

=== "FreeBSD"

    ```bash
    $ ls -l
    -rw-r--r--  1 user wheel  1024 Feb  4 10:00 file.txt
    drwxr-xr-x  2 user wheel   512 Feb  4 10:00 directory/
    lrwxr-xr-x  1 user wheel    10 Feb  4 10:00 link -> file
    crw-rw----  1 root operator 0x50 Feb  4 10:00 /dev/ada0    # диски в FreeBSD — character
    ```
    
    !!! note "FreeBSD: block vs character devices"
        В FreeBSD блочные устройства доступны как **character devices** с буферизацией.
        Традиционные block devices (`/dev/ada0`) были убраны в FreeBSD 5.0.

=== "OpenBSD"

    ```bash
    $ ls -l
    -rw-r--r--  1 user wheel  1024 Feb  4 10:00 file.txt
    drwxr-xr-x  2 user wheel   512 Feb  4 10:00 directory/
    lrwxr-xr-x  1 user wheel    10 Feb  4 10:00 link -> file
    crw-r-----  1 root operator 4, 0 Feb  4 10:00 /dev/sd0c    # raw disk
    brw-r-----  1 root operator 4, 0 Feb  4 10:00 /dev/sd0a    # block device
    ```

**Обозначения типов файлов:**

| Символ | Английское название | Русское название | Описание |
|--------|---------------------|------------------|----------|
| `-` | regular file | обычный файл | Данные пользователя |
| `d` | directory | директория/каталог | Список файлов |
| `l` | symbolic link | символическая ссылка | Указатель на путь |
| `b` | block device | блочное устройство | Диски (доступ блоками) |
| `c` | character device | символьное устройство | Терминалы, порты (побайтовый доступ) |
| `p` | named pipe (FIFO) | именованный канал | Межпроцессное взаимодействие |
| `s` | socket | сокет | Сетевое взаимодействие |

## 1.5 Типы файлов в Windows

Windows не различает типы файлов так явно, как Unix:

- **Обычные файлы** — определяются расширением (`.txt`, `.exe`, `.dll`)
- **Директории** — специальный атрибут
- **Symbolic links** — поддерживаются с Windows Vista (требуют прав администратора)
- **Junction points** — только для директорий (не требуют прав администратора)
- **Hard links** — поддерживаются в NTFS

```powershell
# Просмотр атрибутов
PS> Get-Item file.txt | Select-Object Mode, Name, Length

Mode   Name      Length
----   ----      ------
-a---  file.txt    1024

# Mode расшифровка:
# d - directory
# a - archive
# r - read-only
# h - hidden
# s - system
# l - reparse point (link)
```

## 1.6 Псевдофайлы: «everything is a file» в действии

Философия «всё — файл» раскрывается в полной мере в **виртуальных файловых системах**. Это файловые системы, за которыми нет реального диска — данные генерируются ядром на лету при обращении. Но для пользователя и программ они выглядят как обычные файлы и каталоги, доступные через стандартные `open()`/`read()`/`close()`.

!!! warning "Только Linux"
    `/proc` и `/sys` в описанном ниже виде — это особенность **Linux**. В FreeBSD и OpenBSD `/proc` существует, но устроен проще и часто отключён по умолчанию. macOS не использует `/proc` вовсе. `/dev` существует во всех Unix-системах, но реализован по-разному.

### `/proc` — procfs (process filesystem)

Появился в Unix ещё в 1980-х (Plan 9, AT&T UNIX System V), но в Linux разросся далеко за пределы информации о процессах. Каждый процесс представлен каталогом `/proc/<PID>/`, а общесистемная информация доступна через файлы в корне `/proc`:

```bash
# Информация о процессах
$ ls /proc/1/           # каталог init-процесса (PID 1)
cmdline  cwd  environ  exe  fd  maps  status  ...

$ cat /proc/self/status  # информация о текущем процессе
Name:   bash
State:  S (sleeping)
Pid:    12345

# Информация о системе
$ cat /proc/cpuinfo      # CPU (модель, частота, кэши)
$ cat /proc/meminfo      # RAM (общая, свободная, кэши)
$ cat /proc/uptime       # время работы системы в секундах

# Настройки ядра (можно не только читать, но и записывать!)
$ cat /proc/sys/net/ipv4/ip_forward
0
$ echo 1 > /proc/sys/net/ipv4/ip_forward  # включить маршрутизацию
```

### `/sys` — sysfs (system filesystem)

Появился в Linux 2.6 (2003) как структурированная замена части `/proc`. Предоставляет информацию об **устройствах и драйверах** в виде дерева каталогов:

```bash
# Устройства
$ cat /sys/class/net/eth0/address       # MAC-адрес сетевой карты
$ cat /sys/class/net/eth0/speed         # скорость соединения (Mbps)
$ cat /sys/class/power_supply/BAT0/capacity  # заряд батареи (%)

# Управление оборудованием через запись в файлы
$ echo 50 > /sys/class/backlight/intel_backlight/brightness  # яркость
```

### `/dev` — devfs / udev

В отличие от `/proc` и `/sys`, `/dev` существует во **всех Unix-системах** — это каталог, где устройства представлены файлами. Исторически файлы в `/dev` создавались вручную командой `mknod`. В современном Linux ими управляет **udev** — демон, который автоматически создаёт и удаляет файлы устройств при подключении оборудования.

```bash
# Реальные устройства
$ ls -l /dev/sda          # жёсткий диск
brw-rw---- 1 root disk 8, 0 ...

# Псевдоустройства (существуют всегда, не привязаны к оборудованию)
$ cat /dev/random          # случайные байты (блокируется при нехватке энтропии)
$ cat /dev/urandom         # случайные байты (не блокируется)
$ head -c 16 /dev/zero     # 16 нулевых байт
$ echo "test" > /dev/null  # «чёрная дыра» — данные исчезают
```

!!! note "Псевдофайлы не занимают места на диске"
    ```bash
    $ ls -lh /proc/cpuinfo
    -r--r--r-- 1 root root 0 Feb  4 10:00 /proc/cpuinfo
    ```
    
    Размер показывается как 0, но при чтении ядро генерирует данные на лету.

## 1.7 Определение типа файла

Мы уже знаем, что в Unix есть 7 типов файлов, а в Windows тип определяется расширением. Но как узнать, что на самом деле находится внутри конкретного файла — это текст, изображение или исполняемый файл? Расширение можно подделать, а в Unix оно вообще не имеет специального значения для ОС. Команда `file` решает эту задачу — она анализирует **содержимое** файла (магические байты, сигнатуры), а не его имя:

```bash
$ file document.txt
document.txt: ASCII text

$ file image.jpg
image.jpg: JPEG image data, JFIF standard 1.01

$ file /bin/ls
/bin/ls: ELF 64-bit LSB executable, x86-64

$ file /dev/sda
/dev/sda: block special (8/0)

# Даже если расширение неправильное
$ mv image.jpg fake.txt
$ file fake.txt
fake.txt: JPEG image data, JFIF standard 1.01
```

## 1.8 Создание разных типов файлов

Каждый из 7 типов файлов в Unix создаётся своей командой. Блочные и символьные устройства создаются через `mknod` (требует root) или автоматически демоном udev при подключении оборудования. Сокеты создаются только программно — через системный вызов `socket()`. Остальные типы создаются обычными пользовательскими командами:

```bash
# Обычный файл
$ touch regular_file

# Директория
$ mkdir directory

# Символическая ссылка
$ ln -s /path/to/target symlink

# Жесткая ссылка
$ ln target hardlink

# Named pipe (FIFO)
$ mkfifo mypipe

# Использование pipe
$ echo "hello" > mypipe &  # запись в фоне
$ cat mypipe               # чтение
hello
```

## Резюме

- В Unix **всё является файлом** — единый интерфейс `open()`/`read()`/`write()`/`close()` для любых ресурсов
- Это даёт **7 типов** файлов: regular, directory, symlink, block device, char device, pipe, socket
- **Файл** в узком смысле — именованная область данных с метаданными; в широком — любой объект с файловым интерфейсом
- В Windows типы файлов менее явные, определяются расширением и атрибутами
- **Псевдофайлы** (`/proc`, `/sys`, `/dev`) — яркий пример философии «всё — файл»
- Команда `file` определяет тип по содержимому, а не по расширению


??? question "Упражнения"
    **Задание 1.** Создайте текстовый файл `test.txt`, переименуйте его в `test.jpg`. Выполните `file test.jpg` — какой тип определит система? Почему расширение не влияет на результат?
    
    **Задание 2.** Выполните `ls -la /dev/ | head -20` и `ls -la /proc/self/` (Linux). Определите хотя бы 3 различных типа файлов по первому символу вывода `ls -l`.
    
    **Задание 3.** Напишите Python-скрипт, который с помощью `os.stat()` выводит для заданного файла: размер, номер inode, количество жёстких ссылок и тип (используя модуль `stat`).

!!! tip "Следующая глава"
    Теперь, когда мы знаем, **что такое файл**, давайте разберёмся с **типами файлов** → [Типы файлов](02-file-types-content.md)
