# Глава 3. Метаданные файлов: inode и атрибуты

## Введение

В предыдущей главе мы рассмотрели **7 типов файлов** в Unix. Теперь разберёмся, **какую информацию** операционная система хранит о каждом файле.

Эта информация называется **метаданными** (metadata) — данные О данных.

!!! note "Важно"
    Метаданные хранятся отдельно от содержимого файла. Даже пустой файл (0 байт) имеет метаданные.

---

## 3.1 Что такое inode

**inode** (index node) — это структура данных в Unix-подобных файловых системах, которая хранит **все метаданные файла, кроме имени**.

### Аналогия: библиотечная карточка

Представьте библиотеку:

- **Книга** — это содержимое файла (блоки данных на диске)
- **Каталожная карточка** — это inode (информация о книге: автор, год, полка)
- **Название в каталоге** — это имя файла в директории

Карточка не содержит текст книги, но знает, где её найти.

### Структура inode

Ниже показана **обобщённая структура inode**, характерная для классических Unix-файловых систем:

- **ext2/ext3/ext4** (Linux)
- **UFS/UFS2** (FreeBSD, OpenBSD, NetBSD, Solaris)
- **FFS** (BSD)

```
┌─────────────────────────────────────────────────┐
│                    inode #42                    │
├─────────────────────────────────────────────────┤
│  Тип файла:        regular file (-)             │
│  Права доступа:    rw-r--r-- (644)              │
│  Владелец (UID):   1000                         │
│  Группа (GID):     1000                         │
│  Размер:           4096 bytes                   │
│  Количество ссылок: 1                           │
├─────────────────────────────────────────────────┤
│  Время доступа (atime):    2026-02-04 10:30:00  │
│  Время изменения (mtime):  2026-02-03 15:45:00  │
│  Время смены статуса (ctime): 2026-02-03 15:45:00 │
├─────────────────────────────────────────────────┤
│  Указатели на блоки данных:                     │
│    Прямые:    [1024] [1025] [1026] ...          │
│    Косвенные: [→ блок с указателями]            │
└─────────────────────────────────────────────────┘
```

!!! note "Различия между ФС"
    Конкретные поля и их размеры отличаются:
    
    | ФС | Размер inode | Особенности |
    |----|--------------|-------------|
    | ext4 | 256 байт (по умолчанию) | Наносекундные timestamps, inline data |
    | UFS2 (FreeBSD) | 256 байт | 64-bit timestamps, extended attributes |
    | FFS (OpenBSD) | 128 байт | Классическая BSD-структура |
    | XFS | 256-512 байт | B+ деревья вместо косвенных блоков |
    
    Современные CoW-системы (Btrfs, ZFS) используют **принципиально другую** внутреннюю организацию — см. раздел 3.6.

### Что НЕ хранится в inode

- **Имя файла** — хранится в директории
- **Содержимое файла** — хранится в блоках данных

!!! info "Почему имя не в inode?"
    Потому что у файла может быть **несколько имён** (hard links). Один inode может быть связан с разными именами в разных директориях.

---

## 3.2 Просмотр метаданных

### Команда `stat`

Самый полный способ увидеть метаданные файла:

=== "Linux"

    ```bash
    $ stat myfile.txt
      File: myfile.txt
      Size: 1234            Blocks: 8          IO Block: 4096   regular file
    Device: 8,1    Inode: 131074      Links: 1
    Access: (0644/-rw-r--r--)  Uid: ( 1000/   user)   Gid: ( 1000/   user)
    Access: 2026-02-04 10:30:15.123456789 +0300
    Modify: 2026-02-03 15:45:30.987654321 +0300
    Change: 2026-02-03 15:45:30.987654321 +0300
     Birth: 2026-02-01 09:00:00.000000000 +0300
    
    # Форматированный вывод
    $ stat -c "inode=%i size=%s blocks=%b" myfile.txt
    inode=131074 size=1234 blocks=8
    ```

=== "FreeBSD"

    ```bash
    $ stat myfile.txt
    16777220 131074 -rw-r--r-- 1 user user 0 1234 "Feb  4 10:30:15 2026" \
      "Feb  3 15:45:30 2026" "Feb  3 15:45:30 2026" "Feb  1 09:00:00 2026" \
      4096 8 0 myfile.txt
    
    # Удобный формат
    $ stat -x myfile.txt
      File: "myfile.txt"
      Size: 1234         FileType: Regular File
      Mode: (0644/-rw-r--r--)         Uid: ( 1000/   user)  Gid: ( 1000/   user)
    Device: 0,90   Inode: 131074    Links: 1
    Access: Tue Feb  4 10:30:15 2026
    Modify: Mon Feb  3 15:45:30 2026
    Change: Mon Feb  3 15:45:30 2026
     Birth: Sat Feb  1 09:00:00 2026
    
    # Форматированный вывод (BSD использует -f, не -c)
    $ stat -f "inode=%i size=%z blocks=%b" myfile.txt
    inode=131074 size=1234 blocks=8
    ```

=== "OpenBSD"

    ```bash
    $ stat myfile.txt
    16777220 131074 -rw-r--r-- 1 user user 0 1234 "Feb  4 10:30:15 2026" \
      "Feb  3 15:45:30 2026" "Feb  3 15:45:30 2026" "Feb  1 09:00:00 2026" \
      4096 8 0 myfile.txt
    
    # Форматированный вывод
    $ stat -f "%N: inode=%i size=%z" myfile.txt
    myfile.txt: inode=131074 size=1234
    ```

=== "macOS"

    ```bash
    $ stat myfile.txt
    16777220 131074 -rw-r--r-- 1 user staff 0 1234 "Feb  4 10:30:15 2026" \
      "Feb  3 15:45:30 2026" "Feb  3 15:45:30 2026" "Feb  1 09:00:00 2026" \
      4096 8 0 myfile.txt
    
    # Удобный формат
    $ stat -x myfile.txt
    ```

!!! info "Различия stat между системами"
    | Параметр | Linux (GNU) | BSD/macOS |
    |----------|-------------|-----------|
    | Формат | `-c FORMAT` | `-f FORMAT` |
    | Размер | `%s` | `%z` |
    | Inode | `%i` | `%i` |
    | Блоки | `%b` | `%b` |
    | Расширенный формат | (нет) | `-x` |

**Расшифровка**:

| Поле | Значение | Описание |
|------|----------|----------|
| `Size` | 1234 | Логический размер файла в байтах |
| `Blocks` | 8 | Количество 512-байтных блоков на диске |
| `IO Block` | 4096 | Размер блока ввода-вывода |
| `Inode` | 131074 | Номер inode |
| `Links` | 1 | Количество жёстких ссылок |
| `Access` | 0644 | Права доступа (восьмеричные) |
| `Uid/Gid` | 1000 | ID владельца и группы |

### Команда `ls -li`

Быстрый способ увидеть номер inode:

```bash
$ ls -li
131074 -rw-r--r-- 1 user user 1234 Feb  3 15:45 myfile.txt
^^^^^                                            
номер inode
```

### Python: `os.stat()`

```python
import os
from datetime import datetime

st = os.stat('myfile.txt')

print(f"Inode: {st.st_ino}")
print(f"Size: {st.st_size} bytes")
print(f"Mode: {oct(st.st_mode)}")
print(f"UID: {st.st_uid}, GID: {st.st_gid}")
print(f"Links: {st.st_nlink}")
print(f"Modified: {datetime.fromtimestamp(st.st_mtime)}")
```

Вывод:
```
Inode: 131074
Size: 1234 bytes
Mode: 0o100644
UID: 1000, GID: 1000
Links: 1
Modified: 2026-02-03 15:45:30.987654
```

---

## 3.3 Временные метки (timestamps)

Unix хранит **три** (или четыре) временные метки для каждого файла:

### atime — Access Time

**Когда обновляется**: при **чтении** содержимого файла.

```bash
$ cat myfile.txt        # atime обновляется
$ head -1 myfile.txt    # atime обновляется
$ ls -l myfile.txt      # atime НЕ обновляется (читаются только метаданные)
```

!!! warning "atime может быть отключен"
    Обновление atime при каждом чтении — накладно. Многие системы монтируют диски с опцией `noatime` или `relatime` для производительности:
    
    - `noatime` — никогда не обновлять atime
    - `relatime` — обновлять только если atime < mtime (Linux default)

### mtime — Modification Time

**Когда обновляется**: при **изменении содержимого** файла.

```bash
$ echo "new data" >> myfile.txt   # mtime обновляется
$ truncate -s 0 myfile.txt        # mtime обновляется
$ chmod 755 myfile.txt            # mtime НЕ меняется (только метаданные)
```

!!! tip "mtime — самый полезный timestamp"
    Именно mtime показывается по умолчанию в `ls -l` и используется утилитами вроде `make` для определения, что нужно пересобрать.

### ctime — Change Time (status change)

**Когда обновляется**: при изменении **метаданных** (включая mtime).

```bash
$ chmod 755 myfile.txt            # ctime обновляется
$ chown user:group myfile.txt     # ctime обновляется
$ echo "data" >> myfile.txt       # ctime обновляется (т.к. mtime изменился)
$ ln myfile.txt hardlink          # ctime обновляется (изменился link count)
```

!!! warning "ctime нельзя подделать"
    В отличие от atime и mtime, которые можно установить вручную через `touch -t`, ctime всегда обновляется автоматически. Это важно для безопасности и аудита.

### btime — Birth Time (creation time)

**Время создания файла**. Поддерживается не всеми файловыми системами:

| ФС | btime |
|----|-------|
| ext4 | ✅ (Linux 4.11+) |
| Btrfs | ✅ |
| XFS | ❌ |
| ZFS | ✅ |
| APFS (macOS) | ✅ |
| NTFS | ✅ |

```bash
# Linux: просмотр btime (если поддерживается)
$ stat myfile.txt | grep Birth
 Birth: 2026-02-01 09:00:00.000000000 +0300

# macOS / FreeBSD / OpenBSD: stat показывает birth time по умолчанию
$ stat myfile.txt
...
Access: Wed Feb  4 10:30:15 2026
Modify: Mon Feb  3 15:45:30 2026
Change: Mon Feb  3 18:20:00 2026
 Birth: Sat Feb  1 09:00:00 2026

# FreeBSD: форматированный вывод
$ stat -f "Birth: %SB" myfile.txt
Birth: Feb  1 09:00:00 2026

# FreeBSD/OpenBSD: все timestamps в одну строку
$ stat -f "atime=%Sa mtime=%Sm ctime=%Sc btime=%SB" myfile.txt
atime=Feb  4 10:30:15 2026 mtime=Feb  3 15:45:30 2026 ctime=Feb  3 18:20:00 2026 btime=Feb  1 09:00:00 2026

# macOS: через mdls (Spotlight metadata)
$ mdls -name kMDItemFSCreationDate myfile.txt
kMDItemFSCreationDate = 2026-02-01 06:00:00 +0000
```

!!! note "Различия stat между системами"
    | Система | Формат по умолчанию | Birth time |
    |---------|---------------------|------------|
    | Linux (GNU coreutils) | Многострочный | `Birth:` (если ФС поддерживает) |
    | FreeBSD | Многострочный | Всегда показывает |
    | OpenBSD | Многострочный | Всегда показывает |
    | macOS | Многострочный | Всегда показывает |
    
    BSD-версия `stat` использует флаг `-f` для форматирования, Linux — флаг `-c`.

### Сравнение timestamps

```bash
$ stat myfile.txt
Access: 2026-02-04 10:30:15  # atime — последнее чтение
Modify: 2026-02-03 15:45:30  # mtime — последнее изменение содержимого
Change: 2026-02-03 18:20:00  # ctime — последнее изменение метаданных
 Birth: 2026-02-01 09:00:00  # btime — создание файла
```

**Хронология этого файла**:
1. Создан 1 февраля в 9:00
2. Содержимое изменено 3 февраля в 15:45
3. Права изменены 3 февраля в 18:20 (ctime > mtime)
4. Прочитан 4 февраля в 10:30

---

## 3.4 Размер файла vs размер на диске

Это одна из самых частых путаниц. Рассмотрим подробно.

### Логический размер (Size)

**Size** — это количество байт данных в файле. Именно столько вы получите при чтении файла.

```bash
$ echo -n "Hello" > test.txt   # -n = без newline
$ ls -l test.txt
-rw-r--r-- 1 user user 5 Feb  4 10:00 test.txt
                       ^
                       5 байт
```

### Физический размер (Blocks × 512)

**Blocks** — это количество 512-байтных блоков, реально занятых на диске.

```bash
$ stat test.txt
  Size: 5               Blocks: 8          IO Block: 4096
```

Файл из 5 байт занимает **8 × 512 = 4096 байт** на диске!

### Почему так?

**Файловая система выделяет место блоками**, а не байтами. Типичный размер блока — 4 КБ (4096 байт).

```
┌─────────────────────────────────────────────────┐
│              Блок 4096 байт                     │
├─────┬───────────────────────────────────────────┤
│Hello│                 не используется            │
│5 б  │                   4091 байт                │
└─────┴───────────────────────────────────────────┘
```

!!! note "Внутренняя фрагментация"
    Неиспользуемое место внутри последнего блока называется **внутренней фрагментацией**. Маленькие файлы используют место неэффективно.

### Сравнение `ls` и `du`

```bash
$ ls -l test.txt        # показывает логический размер
-rw-r--r-- 1 user user 5 Feb  4 10:00 test.txt

$ ls -s test.txt        # показывает блоки
4 test.txt              # 4 КБ

$ du -h test.txt        # показывает реальное использование диска
4.0K    test.txt

$ du -b test.txt        # показывает логический размер (apparent size)
5       test.txt

$ du --apparent-size -h test.txt
5       test.txt
```

### Практический пример: миллион мелких файлов

```bash
# Создаём миллион файлов по 1 байту
$ for i in {1..1000000}; do echo -n "X" > file_$i; done

# Логический размер: 1 млн байт ≈ 1 МБ
$ du -b --apparent-size .
1000000    .

# Физический размер: 1 млн × 4 КБ ≈ 4 ГБ!
$ du -sh .
3.9G    .
```

Миллион однобайтных файлов занимают **4 ГБ** на диске!

### Таблица размеров

| Логический размер | Блоков (4K) | На диске |
|-------------------|-------------|----------|
| 1 байт | 1 | 4 КБ |
| 100 байт | 1 | 4 КБ |
| 4096 байт | 1 | 4 КБ |
| 4097 байт | 2 | 8 КБ |
| 10 КБ | 3 | 12 КБ |
| 1 МБ | 256 | 1 МБ |

!!! tip "Правило большого пальца"
    Для файлов > 100 КБ разница между логическим и физическим размером несущественна. Для маленьких файлов — может быть огромной.

### Sparse files (разреженные файлы)

**Sparse file** — файл, в котором «дыры» (нулевые области) не занимают место на диске.

```bash
# Создаём файл с дырой — логически 1 ГБ, физически ~0
$ truncate -s 1G sparse.img

$ ls -lh sparse.img
-rw-r--r-- 1 user user 1.0G Feb  4 10:00 sparse.img

$ du -h sparse.img
0       sparse.img   # На диске — 0!
```

**Как это выглядит в inode:**

```
┌─────────────────────────────────────────────────┐
│              inode sparse file                  │
├─────────────────────────────────────────────────┤
│  Размер (Size): 1 073 741 824 (1 ГБ)            │
│  Блоки на диске (Blocks): 0                     │
├─────────────────────────────────────────────────┤
│  Указатели на блоки:                            │
│    [0..N] = NULL (дыра — нули при чтении)       │
└─────────────────────────────────────────────────┘
```

Когда вы читаете дыру, ядро возвращает нули, не обращаясь к диску.

**Запись в sparse file:**

```bash
# Записываем в середину
$ echo "data" | dd of=sparse.img bs=1 seek=536870912 conv=notrunc

$ du -h sparse.img
4.0K    sparse.img   # Теперь 4 КБ (один блок с данными)

$ ls -lh sparse.img
-rw-r--r-- 1 user user 1.0G Feb  4 10:00 sparse.img  # Размер всё ещё 1 ГБ
```

**Применение:**

- Образы виртуальных машин (qcow2, vmdk)
- Базы данных с предаллоцированным местом
- Торрент-файлы во время скачивания

!!! warning "Копирование sparse files"
    `cp` по умолчанию сохраняет sparse:
    ```bash
    $ cp sparse.img copy.img         # Сохраняет sparse
    $ cp --sparse=never sparse.img full.img  # Заполняет дыры нулями
    ```
    Но `cat sparse.img > copy.img` **разрушит** sparse-структуру!

---

## 3.5 Ограничения inode

### Конечное количество inode

При создании файловой системы выделяется **фиксированное количество inode**.

```bash
$ df -i
Filesystem      Inodes  IUsed   IFree IUse% Mounted on
/dev/sda1      6553600  234567 6318033    4% /
```

Даже если диск не заполнен, можно **исчерпать inode**:

```bash
# Проверяем: диск свободен
$ df -h /
Filesystem      Size  Used Avail Use% Mounted on
/dev/sda1       100G   20G   80G  20% /

# Но inode закончились!
$ touch newfile
touch: cannot touch 'newfile': No space left on device

$ df -i /
Filesystem      Inodes  IUsed   IFree IUse% Mounted on
/dev/sda1      6553600 6553600      0  100% /
```

### Сколько inode по умолчанию?

При создании ext4 выделяется **1 inode на каждые 16 КБ** данных:

| Размер раздела | Примерное кол-во inode |
|----------------|------------------------|
| 1 ГБ | ~65,000 |
| 10 ГБ | ~650,000 |
| 100 ГБ | ~6,500,000 |
| 1 ТБ | ~65,000,000 |

```bash
# Узнать параметры ФС
$ tune2fs -l /dev/sda1 | grep -i inode
Inode count:              6553600
Inodes per group:         8192
Inode size:               256
```

### Когда inode заканчиваются?

Типичные сценарии:

1. **Почтовый сервер** с миллионами писем (каждое письмо = файл)
2. **Веб-сервер** с кешем из мелких файлов
3. **Система мониторинга** с отдельным файлом на каждую метрику
4. **Неудачная распаковка** архива с миллионами файлов

### Решение: выбор ФС или параметров

```bash
# При создании ext4 — указать больше inode
$ mkfs.ext4 -N 20000000 /dev/sdb1   # 20 млн inode

# Или использовать ФС без ограничения inode
# - Btrfs
# - XFS (динамическое выделение inode)
# - ZFS
```

---

## 3.6 Альтернативы inode в других файловых системах

### NTFS (Windows)

Вместо inode используется **MFT (Master File Table)**:

```
┌─────────────────────────────────────────────────┐
│                      MFT                        │
├─────────────────────────────────────────────────┤
│ Record 0: $MFT (сама таблица)                   │
│ Record 1: $MFTMirr (копия первых записей)       │
│ Record 2: $LogFile (журнал транзакций)          │
│ ...                                             │
│ Record N: myfile.txt                            │
│   - Имя файла (!)                               │
│   - Размер, даты, атрибуты                      │
│   - Указатели на данные                         │
└─────────────────────────────────────────────────┘
```

**Отличия от inode**:

- Имя файла хранится **в самой записи MFT** (не в директории)
- Маленькие файлы (< 700 байт) хранятся **прямо в MFT** (resident files)
- MFT растёт динамически (нет фиксированного лимита)

```powershell
# Просмотр MFT информации
PS> fsutil fsinfo ntfsinfo C:
...
Mft Valid Data Length    :  0x00000000c0000000  (3 GB)
Total Mft Records        :  1,572,864
```

### APFS (macOS)

Использует **гибкий контейнер** с динамическим выделением:

- Нет фиксированного количества inode
- Поддержка **клонирования файлов** (copy-on-write)
- **Снапшоты** на уровне файловой системы

```bash
# macOS: информация о файле
$ xattr -l myfile.txt              # расширенные атрибуты
$ mdls myfile.txt                  # метаданные Spotlight
```

### Btrfs / ZFS

Современные copy-on-write файловые системы:

- Динамическое выделение метаданных
- Контрольные суммы для данных и метаданных
- Встроенное сжатие и дедупликация

---

## Резюме

| Концепция | Описание |
|-----------|----------|
| **inode** | Структура, хранящая все метаданные кроме имени |
| **atime** | Время последнего чтения |
| **mtime** | Время последнего изменения содержимого |
| **ctime** | Время последнего изменения метаданных |
| **btime** | Время создания (не везде поддерживается) |
| **Size** | Логический размер файла в байтах |
| **Blocks** | Физическое использование диска |

!!! tip "Практические команды"
    ```bash
    stat file           # Полная информация о метаданных
    ls -li file         # Быстро: inode + основное
    df -i               # Использование inode на разделах
    ```


??? question "Упражнения"
    **Задание 1.** Создайте файл и выполните `stat файл`. Измените содержимое и снова `stat` — какие поля изменились (atime, mtime, ctime) и почему?
    
    **Задание 2.** Выполните `df -i` и подсчитайте, сколько inode свободно. Создайте скрипт, генерирующий 1000 пустых файлов, и снова проверьте `df -i`.
    
    **Задание 3.** Создайте sparse file: `dd if=/dev/zero of=sparse bs=1 count=0 seek=1G`. Сравните вывод `ls -lh sparse` и `du -h sparse`. Объясните разницу.

!!! tip "Следующая глава"
    Теперь мы знаем, **что хранится в inode**. Пора разобраться со ссылками → [Ссылки](04-links.md)
