# Глава 11. От битов к байтам: основы представления данных

## Введение

Прежде чем говорить о кодировках и форматах файлов, нужно понять фундаментальный принцип: **файл — это последовательность байтов**, которые интерпретируются согласно определённым правилам.

```
Байты:     48 65 6c 6c 6f
           ↓  ↓  ↓  ↓  ↓
Символы:   H  e  l  l  o
```

Но что такое байт? Откуда взялись эти правила? И почему именно 8 бит?

---

## 11.1 Бинарный поток в файле

На самом низком уровне файл — это **непрерывная последовательность битов**:

```
01001000011001010110110001101100011011110010000001010111...
```

Компьютер не знает, где заканчивается один символ и начинается другой. Как превратить этот поток в осмысленные данные?

### Байт — минимальная единица данных в файле

Хотя мы говорим «поток битов», на практике **файл не может содержать произвольное количество бит**. Длина любого файла всегда кратна 8 битам, потому что **минимальная атомарная единица данных в файле — 1 байт (8 бит)**.

Это принципиальный момент: информация может нести смысл в одном бите (да/нет, вкл/выкл, 0/1), но **записать в файл один бит невозможно** — минимум, что вы можете записать, это один байт:

```
Хочу сохранить:  1 бит информации (например, флаг «true»)
Реально в файле: 00000001            ← 8 бит = 1 байт
                 ^^^^^^^^
                 7 бит «потрачены впустую» на выравнивание

Хочу сохранить:  3 бита информации (число от 0 до 7)
Реально в файле: 00000101            ← 8 бит = 1 байт (для числа 5)
                      ^^^
                      3 значащих бита, остальные — нули
```

Почему так? Потому что **вся цепочка** — от файловой системы до оперативной памяти и процессора — **адресует данные побайтово**, а не побитово:

```
┌────────────────────────────────────────────────────────────────┐
│  Диск (файловая система)                                       │
│    → хранит файлы блоками (4 КБ), но размер файла — в байтах   │
│                                                                │
│  Оперативная память                                            │
│    → каждый адрес указывает на 1 байт                          │
│                                                                │
│  Процессор                                                     │
│    → системные вызовы read()/write() оперируют байтами         │
│                                                                │
│  Итог: нет механизма для адресации отдельного бита в файле     │
└────────────────────────────────────────────────────────────────┘
```

Поэтому, когда мы говорим «файл — это последовательность битов», это **упрощение**. Точнее будет:

> **Файл — это последовательность байтов**, каждый из которых представляет собой группу из 8 бит.

Если вам нужно хранить данные, которые не кратны байту (например, 12 бит), неиспользуемые биты заполняются нулями (padding):

```python
# Пример: мы хотим сохранить 12-битное число 2048 (0x800)
import struct

value = 2048  # 1000 0000 0000 — 12 значащих бит

# Но записать 12 бит в файл нельзя — нужно минимум 2 байта (16 бит)
with open("value.bin", "wb") as f:
    f.write(struct.pack(">H", value))  # 2 байта: 08 00

# Проверка: файл 2 байта, не 1.5
import os
print(os.path.getsize("value.bin"))  # 2
```

Это ограничение повлияло на всю историю кодировок — именно из-за него ASCII использует ровно 1 байт на символ (7 бит данных + 1 бит padding), а не 7 бит.

### Проблема фрейминга (framing problem)

Итак, файл — последовательность байтов. Но **значение каждого байта** зависит от того, как мы их группируем и интерпретируем:

```
Поток байтов:  48 65 6C 6C 6F 20 57 6F 72 6C 64
               ^^                               
               Это один символ? Часть числа? Начало структуры?

Вопрос: Как узнать границы символов и значений?
```

На уровне отдельных бит внутри байта — та же проблема, но для символов:

```
Поток битов:  01001000011001010110110001101100
              ^^^^^^^^ ← Это один символ? Два? Три?
```

Исторически существовало несколько подходов:

---

## 11.2 Подходы к разбиению потока

### Подход 1: Фиксированная длина символа

**Идея:** Каждый символ занимает ровно N бит. Читаем по N бит за раз.

```
ASCII: каждый символ = 7 бит (+ 1 бит на выравнивание = 8 бит = 1 байт)

Поток:  01001000 01100101 01101100 01101100 01101111
        -------- -------- -------- -------- --------
        0x48     0x65     0x6C     0x6C     0x6F
        H        e        l        l        o
```

**Преимущества:**
- Простота декодирования
- Произвольный доступ: символ N находится на позиции N × размер_символа
- Легко определить длину текста: длина_файла ÷ размер_символа

**Недостатки:**
- Все символы должны умещаться в N бит
- Для языков с большим алфавитом нужно много бит на символ

### Подход 2: Разделители (delimiters)

**Идея:** Между символами стоит специальный маркер.

```
Данные: H|e|l|l|o
        
В битах: [данные H][маркер][данные e][маркер][данные l]...
```

**Проблема:** Что если маркер встретится в данных? Нужно экранирование, что усложняет систему.

### Подход 3: Самосинхронизирующийся код (Self-synchronizing)

**Идея:** По самим данным можно понять, где начало и конец символа.

```
UTF-8 использует этот подход:

Если байт начинается с:
  0xxxxxxx  → Однобайтовый символ (ASCII)            0x00-0x7F
  110xxxxx  → Начало 2-байтового символа             0xC0-0xDF
  1110xxxx  → Начало 3-байтового символа             0xE0-0xEF
  11110xxx  → Начало 4-байтового символа             0xF0-0xF7
  10xxxxxx  → Продолжение многобайтового символа     0x80-0xBF
  
  11111xxx  → НЕВАЛИДНЫЙ байт в UTF-8                0xF8-0xFF
              (Изначально планировались 5-6 байтовые
               последовательности, но RFC 3629 ограничил
               UTF-8 до 4 байт для совместимости с UTF-16,
               который не может представить > U+10FFFF)
```

Подробнее о UTF-8 — в главе [Unicode и UTF-8](14-unicode-utf8.md).

### Сравнение подходов

| Подход | Пример | Длина символа | Произвольный доступ |
|--------|--------|---------------|---------------------|
| Фиксированная длина | ASCII, UTF-32 | Одинаковая | ✅ Да |
| Переменная длина | UTF-8, UTF-16 | Разная | ❌ Нет (нужен перебор) |
| С разделителями | CSV, некоторые протоколы | Разная | ❌ Нет |

---

## 11.3 Байтовая модель

Сегодня используется **байтовая модель**:

```
┌─────────────────────────────────────────────────────────────┐
│  1. Файл = последовательность БАЙТОВ (не битов)             │
│  2. Минимальная адресуемая единица = 1 байт = 8 бит         │
│  3. ASCII-символ = 1 байт (7 бит данных + 1 бит не исп.)    │
└─────────────────────────────────────────────────────────────┘
```

```
Файл на диске:
┌────┬────┬────┬────┬────┬────┐
│ 48 │ 65 │ 6C │ 6C │ 6F │ 0A │  ← Байты (hex)
├────┼────┼────┼────┼────┼────┤
│  H │  e │  l │  l │  o │ \n │  ← ASCII-символы
└────┴────┴────┴────┴────┴────┘
  0    1    2    3    4    5    ← Смещение в байтах
```

### Почему 8 бит, а не 7?

ASCII использует только 7 бит (значения 0-127), но хранится в 8-битных байтах:

```
Символ 'A' (код 65):
  7-битное значение:  1000001
  В 8-битном байте:  01000001
                     ^
                     Старший бит = 0 для ASCII
```

Восьмой бит:
- В чистом ASCII: всегда 0
- В расширенных кодировках (KOI8, CP1251): используется для символов 128-255
- Как бит чётности (parity bit): для проверки ошибок при передаче

### Почему победил байтовый подход?

```
1960-е: Компьютеры с разной длиной слова (12, 18, 36 бит)
        ↓
1970-е: Стандартизация на 8-битный байт (IBM, PDP-11)
        ↓
1980-е: Персональные компьютеры — всё на байтах
        ↓
Сегодня: Байт = универсальная единица данных
```

**Преимущества байтовой модели:**
- Простая адресация: позиция = номер байта
- Совместимость с памятью (адресуется побайтово)  
- ASCII умещается в 1 байт
- Расширяемость: 8-битные кодировки используют байты 128-255
- **Компактная запись**: байт = ровно 2 hex-символа (00-FF)

---

## 11.4 Системы счисления для байтов

Байт (0-255) можно записать в разных системах:

| Decimal | Binary | Hex | Octal | Описание |
|---------|--------|-----|-------|----------|
| 0 | 00000000 | 0x00 | 000 | Минимум |
| 10 | 00001010 | 0x0A | 012 | LF (перевод строки) |
| 13 | 00001101 | 0x0D | 015 | CR (возврат каретки) |
| 32 | 00100000 | 0x20 | 040 | Пробел |
| 48 | 00110000 | 0x30 | 060 | Символ '0' |
| 65 | 01000001 | 0x41 | 101 | Символ 'A' |
| 97 | 01100001 | 0x61 | 141 | Символ 'a' |
| 127 | 01111111 | 0x7F | 177 | DEL (макс. ASCII) |
| 128 | 10000000 | 0x80 | 200 | Начало extended ASCII |
| 255 | 11111111 | 0xFF | 377 | Максимум |

### Преобразование между системами

```python
# Преобразование между системами счисления
value = 65  # Символ 'A'

print(f"Decimal: {value}")           # 65
print(f"Binary:  {value:08b}")       # 01000001
print(f"Hex:     0x{value:02X}")     # 0x41
print(f"Octal:   {value:03o}")       # 101

# Литералы в Python
print(65 == 0b01000001 == 0x41 == 0o101)  # True

# Почему hex удобен для байтов?
# 1 hex-цифра = 4 бита (nibble)
# 2 hex-цифры = 8 бит = 1 байт
#
#   0x41 = 0100 0001
#          ^^^^ ^^^^
#           4    1
```

### Визуализация связи hex и binary

```
Hex    Binary    Hex    Binary
─────────────────────────────────
0      0000      8      1000
1      0001      9      1001
2      0010      A      1010
3      0011      B      1011
4      0100      C      1100
5      0101      D      1101
6      0110      E      1110
7      0111      F      1111

Пример: 0x4A = 0100 1010
              ^^^^|^^^^
               4  |  A
```

---

## 11.5 Процесс чтения бинарного файла

```python
# Пошаговый процесс декодирования

# 1. Читаем сырые байты
with open("hello.txt", "rb") as f:
    raw_bytes = f.read()
    print(f"Байты: {list(raw_bytes)}")
    # Байты: [72, 101, 108, 108, 111, 10]
    
    print(f"Hex: {raw_bytes.hex(' ')}")
    # Hex: 48 65 6c 6c 6f 0a

# 2. Декодируем каждый байт через таблицу ASCII
def decode_ascii(byte_value):
    """Декодирует один байт в ASCII-символ."""
    if byte_value > 127:
        raise ValueError(f"Не ASCII: {byte_value} > 127")
    if byte_value < 32 and byte_value not in (9, 10, 13):
        return f"<{byte_value:02X}>"  # Управляющий символ
    return chr(byte_value)

# 3. Применяем к каждому байту
for i, b in enumerate(raw_bytes):
    binary = format(b, '08b')
    char = decode_ascii(b)
    print(f"Байт {i}: {binary} = 0x{b:02X} = {b:3d} → '{char}'")

# Байт 0: 01001000 = 0x48 =  72 → 'H'
# Байт 1: 01100101 = 0x65 = 101 → 'e'
# Байт 2: 01101100 = 0x6C = 108 → 'l'
# Байт 3: 01101100 = 0x6C = 108 → 'l'
# Байт 4: 01101111 = 0x6F = 111 → 'o'
# Байт 5: 00001010 = 0x0A =  10 → '\n'
```

### Визуализация декодирования

```
Файл "hello.txt" (6 байт):

Уровень битов:
01001000 01100101 01101100 01101100 01101111 00001010
│        │        │        │        │        │
└────────┴────────┴────────┴────────┴────────┴────────→ время/позиция

Уровень байтов:
┌────────┬────────┬────────┬────────┬────────┬────────┐
│  0x48  │  0x65  │  0x6C  │  0x6C  │  0x6F  │  0x0A  │
└────────┴────────┴────────┴────────┴────────┴────────┘

         ↓ ASCII-таблица ↓

Уровень символов:
┌────────┬────────┬────────┬────────┬────────┬────────┐
│   H    │   e    │   l    │   l    │   o    │   ⏎    │
└────────┴────────┴────────┴────────┴────────┴────────┘
```

---

## 11.6 Байты в сетевых протоколах

Байтовая модель — основа всех сетевых протоколов. Вот как байты записываются в разных контекстах:

### MAC-адрес (48 бит = 6 байт)

```
Форматы записи одного и того же MAC-адреса:

00:1A:2B:3C:4D:5E    ← Unix/Linux (двоеточия)
00-1A-2B-3C-4D-5E    ← Windows (дефисы)  
001A.2B3C.4D5E       ← Cisco (точки, по 2 байта)
001A2B3C4D5E         ← Без разделителей

В памяти: 00 1A 2B 3C 4D 5E (6 байт)
```

```python
# Парсинг MAC-адреса
mac_string = "00:1A:2B:3C:4D:5E"
mac_bytes = bytes.fromhex(mac_string.replace(":", ""))
print(list(mac_bytes))  # [0, 26, 43, 60, 77, 94]

# Форматирование
mac_bytes = b'\x00\x1a\x2b\x3c\x4d\x5e'
print(':'.join(f'{b:02X}' for b in mac_bytes))  # 00:1A:2B:3C:4D:5E
```

### IP-адрес (IPv4: 32 бита = 4 байта)

```
Стандартная запись:    192.168.1.100
                       ^^^ ^^^ ^ ^^^
                       байт1.байт2.байт3.байт4

Редкие, но валидные форматы (поддерживаются ping, curl и др.):

Decimal (32-bit число):     3232235876
                            = 192×2²⁴ + 168×2¹⁶ + 1×2⁸ + 100

Octal (каждый октет):       0300.0250.01.0144
                            (0300 = 192, 0250 = 168, 01 = 1, 0144 = 100)

Hex:                        0xC0.0xA8.0x01.0x64
                            или 0xC0A80164

Смешанный:                  192.168.356
                            (356 = 1×256 + 100 = последние 2 октета)

Двухкомпонентный:           192.11010404
                            (11010404 = 168×65536 + 1×256 + 100)
```

```bash
# Все эти команды пингуют один и тот же адрес!
$ ping 192.168.1.100      # Стандартный
$ ping 3232235876         # Decimal
$ ping 0xC0A80164         # Hex
$ ping 0300.0250.01.0144  # Octal

# Проверка
$ python3 -c "import socket; print(socket.inet_ntoa(socket.inet_aton('3232235876')))"
192.168.1.100
```

```python
import struct
import socket

ip = "192.168.1.100"

# Строка → 4 байта
ip_bytes = socket.inet_aton(ip)
print(ip_bytes)  # b'\xc0\xa8\x01d'
print(list(ip_bytes))  # [192, 168, 1, 100]

# 4 байта → 32-битное число
ip_int = struct.unpack('!I', ip_bytes)[0]
print(ip_int)  # 3232235876
print(hex(ip_int))  # 0xc0a80164

# Обратно
print(socket.inet_ntoa(struct.pack('!I', ip_int)))  # 192.168.1.100
```

### Порты TCP/UDP (16 бит = 2 байта)

```
Диапазон портов: 0-65535 (2¹⁶ - 1)

┌─────────────────┬────────────────────────────────┐
│ 0-1023          │ Well-known (требуют root)      │
│ 1024-49151      │ Registered (зарегистрированные)│
│ 49152-65535     │ Dynamic/Private (эфемерные)    │
└─────────────────┴────────────────────────────────┘

Примеры:
  HTTP:  80  = 0x0050
  HTTPS: 443 = 0x01BB
  SSH:   22  = 0x0016
  DNS:   53  = 0x0035
```

```python
# Порт в байтах (big-endian, сетевой порядок)
import struct

port = 443
port_bytes = struct.pack('!H', port)  # '!' = network byte order, 'H' = unsigned short
print(port_bytes)  # b'\x01\xbb'
print(f"Port {port} = 0x{port:04X} = {port_bytes.hex()}")
# Port 443 = 0x01BB = 01bb
```

### Сокет (IP:Port)

```
Сокет = IP-адрес + порт = уникальный endpoint

Формат записи:         192.168.1.100:8080
                       ─────────────┬────
                       IP (4 байта)  Port (2 байта)

В памяти (6 байт):     C0 A8 01 64  1F 90
                       ^^^^^^^^^^^  ^^^^^
                       192.168.1.100  8080

Для IPv6:              [2001:db8::1]:8080
                       (квадратные скобки обязательны из-за двоеточий в IPv6)
```

```python
import socket
import struct

# Создание адреса сокета
addr = ("192.168.1.100", 8080)

# Упаковка в байты
ip_bytes = socket.inet_aton(addr[0])  # 4 байта
port_bytes = struct.pack('!H', addr[1])  # 2 байта
socket_bytes = ip_bytes + port_bytes

print(f"Socket bytes: {socket_bytes.hex(' ')}")
# Socket bytes: c0 a8 01 64 1f 90

# Распаковка
ip = socket.inet_ntoa(socket_bytes[:4])
port = struct.unpack('!H', socket_bytes[4:])[0]
print(f"Parsed: {ip}:{port}")  # 192.168.1.100:8080
```

---

## 11.7 Порядок байтов (Endianness)

```
Проблема: разные CPU хранят многобайтовые числа по-разному

Little-endian (Intel x86):   младший байт первым
Big-endian (сеть, Motorola): старший байт первым

Число 0x01BB (443):
  Big-endian:    01 BB    ← Сетевой порядок
  Little-endian: BB 01    ← Intel

Сетевые протоколы ВСЕГДА используют big-endian!
```

### Визуализация

```
Число: 0x12345678 (4 байта)

Big-endian (сеть, Motorola 68k, SPARC):
┌────┬────┬────┬────┐
│ 12 │ 34 │ 56 │ 78 │  ← Старший байт первым
└────┴────┴────┴────┘
 addr  +1   +2   +3

Little-endian (Intel x86, ARM по умолчанию):
┌────┬────┬────┬────┐
│ 78 │ 56 │ 34 │ 12 │  ← Младший байт первым
└────┴────┴────┴────┘
 addr  +1   +2   +3
```

### Работа с порядком байтов

```python
import struct

port = 443

# Big-endian (сеть)
be = struct.pack('>H', port)  # или '!H'
print(f"Big-endian:    {be.hex(' ')}")  # 01 bb

# Little-endian (Intel)
le = struct.pack('<H', port)
print(f"Little-endian: {le.hex(' ')}")  # bb 01

# Функции преобразования
import socket
print(socket.htons(port))  # Host to Network Short
print(socket.ntohs(0x01BB))  # Network to Host Short
```

### Формат строки struct

| Символ | Порядок байтов |
|--------|----------------|
| `@` | Нативный (системный) |
| `=` | Нативный, стандартный размер |
| `<` | Little-endian |
| `>` | Big-endian |
| `!` | Сетевой (= big-endian) |

### Где порядок байтов критичен

| Формат / Протокол | Порядок байтов | Почему важно знать |
|-------------------|---------------|-------------------|
| TCP/IP, HTTP | Big-endian | «Сетевой порядок» — стандарт для всех сетевых протоколов |
| x86/x64: ELF, PE | Little-endian | Большинство десктопов и серверов |
| ARM | Bi-endian (чаще LE) | Мобильные устройства, Apple Silicon — LE |
| Java `.class` | Big-endian | JVM всегда BE, независимо от платформы |
| TIFF | По BOM (`II`/`MM`) | `II` = Intel = LE, `MM` = Motorola = BE |
| WAV, BMP | Little-endian | Форматы Microsoft |
| PNG | Big-endian | Сетевые истоки формата |
| Protocol Buffers | Little-endian (varint) | Компактные varint'ы |
| MessagePack | Big-endian | Следует сетевому порядку |

```python
# Пример: чтение заголовка TIFF
with open("photo.tiff", "rb") as f:
    bom = f.read(2)
    if bom == b"II":
        endian = "<"  # Little-endian (Intel)
    elif bom == b"MM":
        endian = ">"  # Big-endian (Motorola)
    
    magic = struct.unpack(f"{endian}H", f.read(2))[0]
    assert magic == 42  # "Magic number" TIFF
```

---

## 11.8 Zero-Copy: передача без копирования

При обычной отправке файла по сети данные копируются **4 раза**:

```text
Обычная передача (read + write/send):

  Диск → [DMA] → Буфер ядра → Буфер user-space → Буфер ядра (socket) → [DMA] → Сеть
            1              2                  3                      4

Zero-copy (sendfile):

  Диск → [DMA] → Буфер ядра ──────────────────→ [DMA] → Сеть
            1              (данные НЕ покидают ядро)        2
```

### Системные вызовы

| Вызов | ОС | Описание |
|-------|-----|---------|
| `sendfile()` | Linux, macOS | Передача данных из файлового fd в socket fd без user-space |
| `splice()` | Linux | Перемещение данных между двумя fd через pipe (ещё гибче) |
| `TransmitFile()` | Windows | Аналог sendfile для Windows |
| `copy_file_range()` | Linux 4.5+ | Копирование между файлами без user-space |

### Почему это важно

Веб-серверы (nginx, Apache) используют `sendfile` для статических файлов. Разница:

- **Без zero-copy**: CPU загружен копированием, 4 переключения контекста
- **С zero-copy**: CPU свободен, 2 переключения контекста, пропускная способность выше на **50-80%**

```python
import os

# Python: os.sendfile (Linux/macOS)
with open("large_file.dat", "rb") as src:
    # Отправка файла в socket без промежуточного буфера
    # os.sendfile(socket_fd, src.fileno(), offset, count)
    sent = os.sendfile(sock.fileno(), src.fileno(), 0, os.fstat(src.fileno()).st_size)
```

!!! info "Связь с mmap"
    `mmap` (→ Глава 7) — ещё один способ уменьшить копирование: файл проецируется прямо в адресное пространство. Но `mmap` работает в user-space, а `sendfile` — полностью в ядре, поэтому для сетевой передачи `sendfile` эффективнее.

---

## Резюме

### Ключевые концепции

| Понятие | Описание |
|---------|----------|
| **Бит** | Минимальная единица: 0 или 1 |
| **Байт** | 8 бит, значения 0-255 |
| **Nibble** | 4 бита, значения 0-15 (одна hex-цифра) |
| **Word** | Зависит от архитектуры (16/32/64 бита) |

### Системы счисления

| Система | Основание | Префикс | Пример |
|---------|-----------|---------|--------|
| Binary | 2 | `0b` | `0b01000001` |
| Octal | 8 | `0o` | `0o101` |
| Decimal | 10 | — | `65` |
| Hex | 16 | `0x` | `0x41` |

### Команды для работы с байтами

| Команда | Назначение |
|---------|-----------|
| `hexdump -C file` | Hex-дамп с ASCII |
| `xxd file` | Hex-дамп |
| `xxd -b file` | Binary-дамп |
| `od -tx1 file` | Hex-вывод |
| `od -to1 file` | Octal-вывод |

---

## 11.9 Base64: бинарные данные через текст

### Зачем нужен Base64?

Многие протоколы (email, JSON, URL) работают только с текстом ASCII. Как передать бинарные данные (картинку, файл)?

**Base64** кодирует 3 байта в 4 ASCII-символа:

```
3 байта (24 бита) → разбиваем на 4 группы по 6 бит → 4 символа

Пример: "Man" (0x4D 0x61 0x6E)

01001101 01100001 01101110    ← 3 байта (24 бита)
010011 010110 000101 101110   ← 4 группы по 6 бит
  19     22     5     46      ← Значения 0-63
   T      W     F     u       ← Символы алфавита Base64

Результат: "Man" → "TWFu"
```

### Алфавит Base64

```
Значение 0-25:  A-Z
Значение 26-51: a-z
Значение 52-61: 0-9
Значение 62:    +
Значение 63:    /
Padding:        =
```

### Оверхед +33%

```
Оригинал:  3 байта  → 3 × 8 = 24 бита
Base64:    4 символа → 4 × 8 = 32 бита (4 байта)

Оверхед = 33% (4/3 - 1)
```

### Практика

```bash
# Кодирование
$ echo -n "Hello" | base64
SGVsbG8=

# Декодирование
$ echo "SGVsbG8=" | base64 -d
Hello

# Картинка в Base64
$ base64 -w0 image.png > image.b64
$ wc -c image.png image.b64
   1000 image.png
   1336 image.b64   # +33.6%
```

```python
import base64

# Кодирование
data = b"Hello"
encoded = base64.b64encode(data)
print(encoded)  # b'SGVsbG8='

# Декодирование
decoded = base64.b64decode(encoded)
print(decoded)  # b'Hello'
```

### Data URI — картинки в HTML/CSS

```html
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA...">
```

```css
.icon {
    background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0i...);
}
```

### URL-safe Base64

Стандартный Base64 использует `+` и `/`, которые имеют значение в URL. Альтернатива:

```python
import base64

data = b"Hello!"
standard = base64.b64encode(data)     # SGVsbG8h
url_safe = base64.urlsafe_b64encode(data)  # SGVsbG8h (+ → -, / → _)
```

| Стандартный | URL-safe |
|-------------|----------|
| `+` | `-` |
| `/` | `_` |

---

## 11.10 URL-encoding (Percent-encoding)

Ещё один способ передачи «проблемных» символов через текстовый канал — **URL-encoding**. В URL можно использовать только ASCII-безопасные символы. Остальные кодируются как `%XX`, где XX — hex-код байта:

### Таблица часто кодируемых символов

| Символ | URL-encoded | Hex байт | Описание |
|--------|-------------|----------|----------|
| (пробел) | `%20` или `+` | `0x20` | Пробел |
| `!` | `%21` | `0x21` | Восклицательный знак |
| `#` | `%23` | `0x23` | Хэш (фрагмент URL) |
| `%` | `%25` | `0x25` | Сам символ процента |
| `&` | `%26` | `0x26` | Разделитель параметров |
| `+` | `%2B` | `0x2B` | Плюс |
| `/` | `%2F` | `0x2F` | Разделитель пути |
| `=` | `%3D` | `0x3D` | Разделитель ключ=значение |
| `?` | `%3F` | `0x3F` | Начало query string |
| `@` | `%40` | `0x40` | «Собака» |

Для **не-ASCII символов** (кириллица, эмодзи) сначала кодируются в UTF-8, затем каждый байт — через `%XX`:

```
"Файл" → UTF-8 → D0 A4 D0 B0 D0 B9 D0 BB → %D0%A4%D0%B0%D0%B9%D0%BB
```

```python
from urllib.parse import quote, unquote, urlencode

# Кодирование строки
print(quote("Файл данных.txt"))
# '%D0%A4%D0%B0%D0%B9%D0%BB%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85.txt'

# Декодирование
print(unquote("%D0%A4%D0%B0%D0%B9%D0%BB"))
# 'Файл'

# Кодирование параметров
params = {"q": "файлы & форматы", "page": 1}
print(urlencode(params))
# 'q=%D0%A4%D0%B0%D0%B9%D0%BB%D1%8B+%26+%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D1%8B&page=1'
```

```bash
# В командной строке (curl автоматически кодирует)
$ curl -G "https://api.example.com/search" --data-urlencode "q=файлы & данные"
```

---

## 11.11 Другие способы кодирования бинарных данных в текст

Base64 — не единственный способ. Разные схемы дают разный баланс оверхеда и удобства:

| Кодирование | Оверхед | Алфавит | Где применяется |
|-------------|---------|---------|-----------------|
| **Hex (Base16)** | +100% | `0-9`, `A-F` | Дампы, хэши, MAC-адреса |
| **Base32** | +60% | `A-Z`, `2-7` | TOTP (Google Authenticator) |
| **Base64** | +33% | `A-Za-z0-9+/` | Email, JSON, Data URI |
| **Base85 (Ascii85)** | +25% | 85 ASCII-символов | PostScript, PDF, git |
| **uuencode** | +33% | 32-95 ASCII | USENET (устарел) |

```python
import base64
import binascii

data = b"Hello!"

# Hex
print(data.hex())                    # '48656c6c6f21'  (+100%)
print(bytes.fromhex('48656c6c6f21')) # b'Hello!'

# Base32
print(base64.b32encode(data))       # b'JBSWY3DPEE=====' (+60%)

# Base64
print(base64.b64encode(data))       # b'SGVsbG8h'       (+33%)

# Base85 (Ascii85)
print(base64.b85encode(data))       # b'NM&qnZy'        (+25%)
```

!!! info "Когда что использовать"
    - **Hex** — когда важна читаемость (хэши SHA-256, адреса, дампы)
    - **Base32** — когда нужен case-insensitive алфавит (TOTP-коды)
    - **Base64** — стандарт для передачи бинарных данных в тексте
    - **Base85** — когда каждый байт на счету (PDF, git packfiles)


??? question "Упражнения"
    **Задание 1.** Закодируйте строку "Hello, Мир!" в Base64 вручную (или через `base64` CLI). Декодируйте обратно. Почему результат длиннее исходной строки?
    
    **Задание 2.** Напишите Python-функцию, которая определяет, является ли файл текстовым или бинарным (проверяя наличие нулевых байтов и непечатаемых символов).
    
    **Задание 3.** Сколько байт занимает IPv4-адрес `192.168.1.1` в бинарном представлении vs в текстовом? А IPv6-адрес? Продемонстрируйте через `socket.inet_pton`.

!!! tip "Следующая глава"
    Теперь, когда мы понимаем байты и их представление, можно изучить **ASCII** — первый стандарт кодирования символов → [ASCII: фундамент текстовых данных](12-ascii.md)
