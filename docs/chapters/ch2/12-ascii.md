# Глава 12. ASCII: Фундамент текстовых данных

## Введение

В предыдущей главе мы разобрались с битами и байтами. Теперь посмотрим, как байты превращаются в **текст** — и начнём с первого универсального стандарта кодирования символов.

---

## 12.1 История ASCII

**ASCII** (American Standard Code for Information Interchange) — стандарт кодирования символов, разработанный в 1963 году и окончательно утверждённый в 1967 году.

### Предпосылки

До ASCII существовало множество несовместимых кодировок:

- **Baudot code** (1870) — 5-битная кодировка для телеграфа
- **EBCDIC** (1963) — кодировка IBM для мейнфреймов
- Десятки проприетарных кодировок от разных производителей

**Проблема:** Текст, созданный на одном компьютере, невозможно было прочитать на другом.

### Рождение стандарта

В 1960-х годах комитет ASA (American Standards Association, позже ANSI) разработал единый стандарт:

```
┌─────────────────────────────────────────────────────────────┐
│                         ASCII                               │
├─────────────────────────────────────────────────────────────┤
│  • 7 бит на символ (0-127)                                  │
│  • 128 возможных значений                                   │
│  • Совместимость с телетайпами                              │
│  • Логичная организация (A < B < C...)                      │
│  • Управляющие символы для терминалов                       │
└─────────────────────────────────────────────────────────────┘
```

---

## 12.2 Структура ASCII

### Разбивка по диапазонам

```
┌────────────────────────────────────────────────────────────┐
│  0x00 - 0x1F (0-31):   Управляющие символы                 │
│                        NUL, TAB, LF, CR, ESC...            │
├────────────────────────────────────────────────────────────┤
│  0x20 - 0x2F (32-47):  Пунктуация и спецсимволы            │
│                        SPACE ! " # $ % & ' ( ) * + , - . / │
├────────────────────────────────────────────────────────────┤
│  0x30 - 0x39 (48-57):  Цифры                               │
│                        0 1 2 3 4 5 6 7 8 9                 │
├────────────────────────────────────────────────────────────┤
│  0x3A - 0x40 (58-64):  Пунктуация                          │
│                        : ; < = > ? @                       │
├────────────────────────────────────────────────────────────┤
│  0x41 - 0x5A (65-90):  Заглавные буквы                     │
│                        A B C ... Z                         │
├────────────────────────────────────────────────────────────┤
│  0x5B - 0x60 (91-96):  Спецсимволы                         │
│                        [ \ ] ^ _ `                         │
├────────────────────────────────────────────────────────────┤
│  0x61 - 0x7A (97-122): Строчные буквы                      │
│                        a b c ... z                         │
├────────────────────────────────────────────────────────────┤
│  0x7B - 0x7E (123-126): Спецсимволы                        │
│                         { | } ~                            │
├────────────────────────────────────────────────────────────┤
│  0x7F (127):           DEL (delete)                        │
└────────────────────────────────────────────────────────────┘
```

### Полная таблица печатных символов

```
      0 1 2 3 4 5 6 7 8 9 A B C D E F
   ┌────────────────────────────────────
2x │ SP ! " # $ % & ' ( ) * + , - . /
3x │  0 1 2 3 4 5 6 7 8 9 : ; < = > ?
4x │  @ A B C D E F G H I J K L M N O
5x │  P Q R S T U V W X Y Z [ \ ] ^ _
6x │  ` a b c d e f g h i j k l m n o
7x │  p q r s t u v w x y z { | } ~ DEL
```

### Ключевые особенности

```python
# 1. Цифры идут подряд (0x30-0x39)
for i in range(10):
    code = 0x30 + i
    print(f"'{chr(code)}' = 0x{code:02X} = {code}")
# '0' = 0x30 = 48
# '1' = 0x31 = 49
# ...
# '9' = 0x39 = 57

# 2. Заглавные буквы: 0x41-0x5A
print(f"'A' = 0x{ord('A'):02X}")  # 'A' = 0x41
print(f"'Z' = 0x{ord('Z'):02X}")  # 'Z' = 0x5A

# 3. Строчные буквы: 0x61-0x7A (на 0x20 больше заглавных)
print(f"'a' = 0x{ord('a'):02X}")  # 'a' = 0x61
print(f"'z' = 0x{ord('z'):02X}")  # 'z' = 0x7A

# 4. Преобразование регистра: XOR 0x20
char = 'A'
lower = chr(ord(char) ^ 0x20)
print(f"'{char}' → '{lower}'")  # 'A' → 'a'

char = 'a'
upper = chr(ord(char) ^ 0x20)
print(f"'{char}' → '{upper}'")  # 'a' → 'A'
```

---

## 12.3 Полная таблица ASCII

### Управляющие символы (0x00–0x1F)

| Dec | Hex | Бинарный | Символ | Escape | Название | Описание |
|-----|-----|----------|--------|--------|----------|----------|
| 0 | 0x00 | 0000000 | ␀ | `\0` | NUL | Null — конец строки в C |
| 1 | 0x01 | 0000001 | ␁ | `^A` | SOH | Start of Heading |
| 2 | 0x02 | 0000010 | ␂ | `^B` | STX | Start of Text |
| 3 | 0x03 | 0000011 | ␃ | `^C` | ETX | End of Text (Ctrl+C — прерывание) |
| 4 | 0x04 | 0000100 | ␄ | `^D` | EOT | End of Transmission (Ctrl+D — EOF) |
| 5 | 0x05 | 0000101 | ␅ | `^E` | ENQ | Enquiry |
| 6 | 0x06 | 0000110 | ␆ | `^F` | ACK | Acknowledge |
| 7 | 0x07 | 0000111 | ␇ | `\a` | BEL | Bell — звуковой сигнал |
| 8 | 0x08 | 0001000 | ␈ | `\b` | BS | Backspace — забой |
| 9 | 0x09 | 0001001 | ␉ | `\t` | HT | Horizontal Tab — табуляция |
| 10 | 0x0A | 0001010 | ␊ | `\n` | LF | Line Feed — перевод строки |
| 11 | 0x0B | 0001011 | ␋ | `\v` | VT | Vertical Tab — верт. табуляция |
| 12 | 0x0C | 0001100 | ␌ | `\f` | FF | Form Feed — новая страница |
| 13 | 0x0D | 0001101 | ␍ | `\r` | CR | Carriage Return — возврат каретки |
| 14 | 0x0E | 0001110 | ␎ | `^N` | SO | Shift Out |
| 15 | 0x0F | 0001111 | ␏ | `^O` | SI | Shift In |
| 16 | 0x10 | 0010000 | ␐ | `^P` | DLE | Data Link Escape |
| 17 | 0x11 | 0010001 | ␑ | `^Q` | DC1 | Device Control 1 (XON) |
| 18 | 0x12 | 0010010 | ␒ | `^R` | DC2 | Device Control 2 |
| 19 | 0x13 | 0010011 | ␓ | `^S` | DC3 | Device Control 3 (XOFF) |
| 20 | 0x14 | 0010100 | ␔ | `^T` | DC4 | Device Control 4 |
| 21 | 0x15 | 0010101 | ␕ | `^U` | NAK | Negative Acknowledge |
| 22 | 0x16 | 0010110 | ␖ | `^V` | SYN | Synchronous Idle |
| 23 | 0x17 | 0010111 | ␗ | `^W` | ETB | End of Transmission Block |
| 24 | 0x18 | 0011000 | ␘ | `^X` | CAN | Cancel |
| 25 | 0x19 | 0011001 | ␙ | `^Y` | EM | End of Medium |
| 26 | 0x1A | 0011010 | ␚ | `^Z` | SUB | Substitute (Ctrl+Z — EOF в Windows) |
| 27 | 0x1B | 0011011 | ␛ | `\e` | ESC | Escape — начало escape-последовательностей |
| 28 | 0x1C | 0011100 | ␜ | `^\` | FS | File Separator |
| 29 | 0x1D | 0011101 | ␝ | `^]` | GS | Group Separator |
| 30 | 0x1E | 0011110 | ␞ | `^^` | RS | Record Separator |
| 31 | 0x1F | 0011111 | ␟ | `^_` | US | Unit Separator |

### Печатные символы (0x20–0x7E)

#### Пробел и знаки препинания (0x20–0x2F)

| Dec | Hex | Бинарный | Символ | Название/Описание |
|-----|-----|----------|--------|-------------------|
| 32 | 0x20 | 0100000 | ` ` | Space — пробел |
| 33 | 0x21 | 0100001 | `!` | Exclamation mark — восклицательный знак |
| 34 | 0x22 | 0100010 | `"` | Quotation mark — двойная кавычка |
| 35 | 0x23 | 0100011 | `#` | Number sign — решётка, хеш |
| 36 | 0x24 | 0100100 | `$` | Dollar sign — доллар |
| 37 | 0x25 | 0100101 | `%` | Percent sign — процент |
| 38 | 0x26 | 0100110 | `&` | Ampersand — амперсанд |
| 39 | 0x27 | 0100111 | `'` | Apostrophe — апостроф, одинарная кавычка |
| 40 | 0x28 | 0101000 | `(` | Left parenthesis — левая скобка |
| 41 | 0x29 | 0101001 | `)` | Right parenthesis — правая скобка |
| 42 | 0x2A | 0101010 | `*` | Asterisk — звёздочка |
| 43 | 0x2B | 0101011 | `+` | Plus sign — плюс |
| 44 | 0x2C | 0101100 | `,` | Comma — запятая |
| 45 | 0x2D | 0101101 | `-` | Hyphen-minus — дефис, минус |
| 46 | 0x2E | 0101110 | `.` | Full stop — точка |
| 47 | 0x2F | 0101111 | `/` | Solidus — косая черта, слеш |

#### Цифры (0x30–0x39)

| Dec | Hex | Бинарный | Символ | Примечание |
|-----|-----|----------|--------|------------|
| 48 | 0x30 | 0110000 | `0` | Цифра ноль |
| 49 | 0x31 | 0110001 | `1` | Цифра один |
| 50 | 0x32 | 0110010 | `2` | Цифра два |
| 51 | 0x33 | 0110011 | `3` | Цифра три |
| 52 | 0x34 | 0110100 | `4` | Цифра четыре |
| 53 | 0x35 | 0110101 | `5` | Цифра пять |
| 54 | 0x36 | 0110110 | `6` | Цифра шесть |
| 55 | 0x37 | 0110111 | `7` | Цифра семь |
| 56 | 0x38 | 0111000 | `8` | Цифра восемь |
| 57 | 0x39 | 0111001 | `9` | Цифра девять |

#### Знаки препинания (0x3A–0x40)

| Dec | Hex | Бинарный | Символ | Название/Описание |
|-----|-----|----------|--------|-------------------|
| 58 | 0x3A | 0111010 | `:` | Colon — двоеточие |
| 59 | 0x3B | 0111011 | `;` | Semicolon — точка с запятой |
| 60 | 0x3C | 0111100 | `<` | Less-than sign — меньше |
| 61 | 0x3D | 0111101 | `=` | Equals sign — равно |
| 62 | 0x3E | 0111110 | `>` | Greater-than sign — больше |
| 63 | 0x3F | 0111111 | `?` | Question mark — вопросительный знак |
| 64 | 0x40 | 1000000 | `@` | Commercial at — собака, at |

#### Заглавные буквы (0x41–0x5A)

| Dec | Hex | Бинарный | Символ | | Dec | Hex | Бинарный | Символ |
|-----|-----|----------|--------|---|-----|-----|----------|--------|
| 65 | 0x41 | 1000001 | `A` | | 78 | 0x4E | 1001110 | `N` |
| 66 | 0x42 | 1000010 | `B` | | 79 | 0x4F | 1001111 | `O` |
| 67 | 0x43 | 1000011 | `C` | | 80 | 0x50 | 1010000 | `P` |
| 68 | 0x44 | 1000100 | `D` | | 81 | 0x51 | 1010001 | `Q` |
| 69 | 0x45 | 1000101 | `E` | | 82 | 0x52 | 1010010 | `R` |
| 70 | 0x46 | 1000110 | `F` | | 83 | 0x53 | 1010011 | `S` |
| 71 | 0x47 | 1000111 | `G` | | 84 | 0x54 | 1010100 | `T` |
| 72 | 0x48 | 1001000 | `H` | | 85 | 0x55 | 1010101 | `U` |
| 73 | 0x49 | 1001001 | `I` | | 86 | 0x56 | 1010110 | `V` |
| 74 | 0x4A | 1001010 | `J` | | 87 | 0x57 | 1010111 | `W` |
| 75 | 0x4B | 1001011 | `K` | | 88 | 0x58 | 1011000 | `X` |
| 76 | 0x4C | 1001100 | `L` | | 89 | 0x59 | 1011001 | `Y` |
| 77 | 0x4D | 1001101 | `M` | | 90 | 0x5A | 1011010 | `Z` |

#### Спецсимволы (0x5B–0x60)

| Dec | Hex | Бинарный | Символ | Название/Описание |
|-----|-----|----------|--------|-------------------|
| 91 | 0x5B | 1011011 | `[` | Left square bracket — левая квадратная скобка |
| 92 | 0x5C | 1011100 | `\` | Reverse solidus — обратная косая черта, бэкслеш |
| 93 | 0x5D | 1011101 | `]` | Right square bracket — правая квадратная скобка |
| 94 | 0x5E | 1011110 | `^` | Circumflex accent — циркумфлекс, карет |
| 95 | 0x5F | 1011111 | `_` | Low line — подчёркивание |
| 96 | 0x60 | 1100000 | `` ` `` | Grave accent — обратный апостроф, бэктик |

#### Строчные буквы (0x61–0x7A)

| Dec | Hex | Бинарный | Символ | | Dec | Hex | Бинарный | Символ |
|-----|-----|----------|--------|---|-----|-----|----------|--------|
| 97 | 0x61 | 1100001 | `a` | | 110 | 0x6E | 1101110 | `n` |
| 98 | 0x62 | 1100010 | `b` | | 111 | 0x6F | 1101111 | `o` |
| 99 | 0x63 | 1100011 | `c` | | 112 | 0x70 | 1110000 | `p` |
| 100 | 0x64 | 1100100 | `d` | | 113 | 0x71 | 1110001 | `q` |
| 101 | 0x65 | 1100101 | `e` | | 114 | 0x72 | 1110010 | `r` |
| 102 | 0x66 | 1100110 | `f` | | 115 | 0x73 | 1110011 | `s` |
| 103 | 0x67 | 1100111 | `g` | | 116 | 0x74 | 1110100 | `t` |
| 104 | 0x68 | 1101000 | `h` | | 117 | 0x75 | 1110101 | `u` |
| 105 | 0x69 | 1101001 | `i` | | 118 | 0x76 | 1110110 | `v` |
| 106 | 0x6A | 1101010 | `j` | | 119 | 0x77 | 1110111 | `w` |
| 107 | 0x6B | 1101011 | `k` | | 120 | 0x78 | 1111000 | `x` |
| 108 | 0x6C | 1101100 | `l` | | 121 | 0x79 | 1111001 | `y` |
| 109 | 0x6D | 1101101 | `m` | | 122 | 0x7A | 1111010 | `z` |

#### Спецсимволы и DEL (0x7B–0x7F)

| Dec | Hex | Бинарный | Символ | Название/Описание |
|-----|-----|----------|--------|-------------------|
| 123 | 0x7B | 1111011 | `{` | Left curly bracket — левая фигурная скобка |
| 124 | 0x7C | 1111100 | `\|` | Vertical line — вертикальная черта, пайп |
| 125 | 0x7D | 1111101 | `}` | Right curly bracket — правая фигурная скобка |
| 126 | 0x7E | 1111110 | `~` | Tilde — тильда |
| 127 | 0x7F | 1111111 | ␡ | DEL — Delete, управляющий символ удаления |

### Закономерности в таблице

```python
# 1. Цифры: младшие 4 бита = значение цифры
for digit in "0123456789":
    code = ord(digit)
    value = code & 0x0F  # Маска младших 4 бит
    print(f"'{digit}': 0x{code:02X} & 0x0F = {value}")
# '0': 0x30 & 0x0F = 0
# '5': 0x35 & 0x0F = 5
# '9': 0x39 & 0x0F = 9

# 2. Регистр: отличается только бит 5 (0x20)
print(f"'A' = 0x{ord('A'):02X} = {ord('A'):07b}")  # 1000001
print(f"'a' = 0x{ord('a'):02X} = {ord('a'):07b}")  # 1100001
#                                     ^ бит 5

# Быстрое преобразование регистра
def to_lower(c):
    return chr(ord(c) | 0x20)   # Установить бит 5

def to_upper(c):
    return chr(ord(c) & ~0x20)  # Сбросить бит 5

# 3. Ctrl + буква = код 1-26
# Ctrl+A = 1, Ctrl+Z = 26
for i, letter in enumerate("ABCDEFGHIJKLMNOPQRSTUVWXYZ", 1):
    print(f"Ctrl+{letter} = {i} (0x{i:02X})")
```

---

## 12.4 Управляющие символы подробнее

Первые 32 кода (0x00-0x1F) и код 0x7F — **управляющие символы** (control characters). Они не отображаются, а выполняют действия.

### Таблица управляющих символов

| Код | Hex | Символ | Название | Назначение |
|-----|-----|--------|----------|------------|
| 0 | 0x00 | NUL | Null | Конец строки в C (`\0`) |
| 7 | 0x07 | BEL | Bell | Звуковой сигнал (`\a`) |
| 8 | 0x08 | BS | Backspace | Удаление символа (`\b`) |
| 9 | 0x09 | HT | Horizontal Tab | Табуляция (`\t`) |
| 10 | 0x0A | LF | Line Feed | Новая строка (`\n`) |
| 11 | 0x0B | VT | Vertical Tab | Вертикальная табуляция (`\v`) |
| 12 | 0x0C | FF | Form Feed | Новая страница (`\f`) |
| 13 | 0x0D | CR | Carriage Return | Возврат каретки (`\r`) |
| 27 | 0x1B | ESC | Escape | Начало escape-последовательности |
| 32 | 0x20 | SP | Space | Пробел (технически печатный) |
| 127 | 0x7F | DEL | Delete | Удаление (телетайп) |

### Escape-последовательности терминала

Символ ESC (0x1B) используется для управления терминалом:

```python
# ANSI escape codes
print("\033[31mКрасный текст\033[0m")
print("\033[1;32mЗелёный жирный\033[0m")
print("\033[4mПодчёркнутый\033[0m")

# Очистка экрана
print("\033[2J\033[H")  # Clear screen, move cursor home
```

!!! info "Что такое `\033`?"
    `\033` — это **восьмеричная (octal) запись** числа 27 (ESC).
    
    ```
    Три способа записать ESC в строке:
    
    \033  — восьмеричная нотация (0-3-3 в base 8 = 27)
    \x1B  — шестнадцатеричная нотация (1B в base 16 = 27)
    \e    — мнемоническое обозначение (не во всех языках)
    ```
    
    Почему восьмеричная? Исторически Unix использовал octal:
    
    ```python
    # Все три варианта эквивалентны
    print("\033[31mRed\033[0m")   # Octal
    print("\x1b[31mRed\x1b[0m")   # Hex
    
    # Проверка
    print(0o33)      # 27 (octal literal в Python)
    print(0x1B)      # 27 (hex literal)
    print(ord('\033'))  # 27
    print(ord('\x1b'))  # 27
    ```
    
    | Нотация | Пример | Основание | Расчёт |
    |---------|--------|-----------|--------|
    | Octal | `\033` | 8 | 0×64 + 3×8 + 3×1 = 27 |
    | Hex | `\x1B` | 16 | 1×16 + 11×1 = 27 |
    | Decimal | `chr(27)` | 10 | 27 |

```python
# Позиционирование курсора
print("\033[10;20H")    # Move to row 10, column 20
```

```bash
# В bash
$ echo -e "\033[31mRed\033[0m"
Red

# Прогресс-бар с возвратом каретки
$ for i in {1..100}; do echo -ne "\r$i%"; sleep 0.1; done
```

**Разбор прогресс-бара:**

```bash
for i in {1..100}; do    # Цикл от 1 до 100
    echo -ne "\r$i%"     # Вывод с возвратом каретки
    sleep 0.1            # Пауза 0.1 секунды
done

# Флаги echo:
#   -n  — не добавлять \n в конце (остаёмся на той же строке)
#   -e  — интерпретировать escape-последовательности (\r, \033 и т.д.)

# Как это работает:
#
# Шаг 1: echo -ne "\r1%"
#        \r возвращает курсор в начало строки
#        Выводится "1%"
#        Терминал показывает: "1%"
#
# Шаг 2: echo -ne "\r2%"
#        \r снова возвращает курсор в начало
#        "2%" перезаписывает "1%"
#        Терминал показывает: "2%"
#
# ...
#
# Шаг 100: echo -ne "\r100%"
#          Терминал показывает: "100%"

# Визуализация работы \r:
#
# Позиция курсора: [█]
#
# echo -n "Hello"     →  Hello[█]        (курсор после 'o')
# echo -ne "\r"       →  [█]ello         (курсор вернулся в начало)
# echo -n "World"     →  World[█]        ('Hello' перезаписано)
```

**Более продвинутый прогресс-бар:**

```bash
# С визуальной полосой прогресса
for i in {1..50}; do
    # Формируем полосу: [=====>    ] 50%
    filled=$((i * 20 / 50))           # Сколько символов заполнено
    empty=$((20 - filled))            # Сколько пустых
    bar=$(printf '=%.0s' $(seq 1 $filled))$(printf ' %.0s' $(seq 1 $empty))
    printf "\r[%s] %3d%%" "$bar" $((i * 2))
    sleep 0.1
done
echo  # Переход на новую строку в конце

# Результат:
# [====================] 100%
```

```python
# То же самое в Python
import time
import sys

for i in range(1, 101):
    # \r — возврат каретки, end='' — без перевода строки
    print(f"\r{i}%", end='')
    sys.stdout.flush()  # Принудительный вывод буфера
    time.sleep(0.05)

print()  # Новая строка в конце

# Или с полосой прогресса
for i in range(1, 51):
    filled = i * 20 // 50
    bar = '=' * filled + ' ' * (20 - filled)
    print(f"\r[{bar}] {i*2:3d}%", end='', flush=True)
    time.sleep(0.05)
print()
```

### BEL — звуковой сигнал

```bash
# Звуковой сигнал терминала
$ echo -e "\a"

# В Python
print("\a")

# В скриптах — оповещение об окончании
$ long_running_command; echo -e "\a"
```

---

## 12.5 Переносы строк: LF, CR, CRLF

Один из главных источников проблем совместимости — **разные переносы строк** в разных ОС.

### Исторический контекст

```
Телетайп (механическая печатная машинка):

1. CR (Carriage Return) — вернуть каретку в начало строки
   ├────────────────────────────────────┤
   ▲                                    │
   │◄───────────────────────────────────┘
   каретка возвращается

2. LF (Line Feed) — прокрутить бумагу на строку вверх
   ┌────────────────────────────────────┐
   │ Предыдущая строка                  │
   │ ▼ ▼ ▼ ▼ ▼ ▼ ▼ ▼ ▼ ▼ ▼ ▼ ▼ ▼ ▼ ▼  │
   │ Новая строка                       │
   └────────────────────────────────────┘
```

### Современные стандарты

| ОС | Перенос строки | Hex | Escape |
|----|----------------|-----|--------|
| **Unix/Linux/macOS** | LF | 0x0A | `\n` |
| **Windows** | CRLF | 0x0D 0x0A | `\r\n` |
| **Старый Mac (до OS X)** | CR | 0x0D | `\r` |

### Практические примеры

```bash
# Создаём файл на Unix
$ echo "Hello" > unix.txt
$ hexdump -C unix.txt
00000000  48 65 6c 6c 6f 0a                                 |Hello.|
                       ^^
                       LF

# Конвертируем в Windows-формат
$ unix2dos unix.txt
$ hexdump -C unix.txt
00000000  48 65 6c 6c 6f 0d 0a                              |Hello..|
                       ^^ ^^
                       CR LF

# Обратно в Unix
$ dos2unix unix.txt
```

### Проблемы совместимости

```bash
# Скрипт с Windows-переносами не работает на Linux
$ cat -A script.sh
#!/bin/bash^M
echo "Hello"^M

$ bash script.sh
bash: script.sh: line 1: $'\r': command not found

# Исправление
$ dos2unix script.sh
$ bash script.sh
Hello
```

### Обработка в Python

```python
# Python автоматически нормализует переносы при чтении
with open("file.txt", "r") as f:
    text = f.read()  # \r\n → \n

# Чтение без преобразования
with open("file.txt", "rb") as f:
    raw = f.read()
    print(raw)  # b'Hello\r\n'

# Явный режим переносов
with open("file.txt", "r", newline='') as f:
    text = f.read()  # Сохраняет оригинальные переносы

# Запись с конкретными переносами
with open("file.txt", "w", newline='\r\n') as f:
    f.write("Hello\n")  # Запишет Hello\r\n
```

### Git и переносы строк

```bash
# Настройка Git
$ git config --global core.autocrlf input    # На Unix/macOS
$ git config --global core.autocrlf true     # На Windows

# .gitattributes для явного контроля
# .gitattributes
* text=auto
*.sh text eol=lf
*.bat text eol=crlf
*.png binary
```

---

## 12.6 Экранирование и представление символов

Когда символ нельзя или неудобно использовать напрямую, его **экранируют** — представляют через код. Это базовая концепция, применимая далеко за пределами ASCII.

### Зачем нужно экранирование

- **Непечатные символы** — нельзя набрать на клавиатуре (NUL, ESC, Tab)
- **Специальные символы** — имеют особое значение в контексте (`"` в строке, `/` в пути)
- **Совместимость** — передача бинарных данных через текстовые протоколы
- **Безопасность** — предотвращение injection-атак

### Форматы экранирования

| Контекст | Формат | Пример (пробел, 0x20) | Пример (кириллица «А», U+0410) |
|----------|--------|----------------------|-------------------------------|
| C, Python, Bash | `\xNN` | `\x20` | — (только 1 байт) |
| URL (percent-encoding) | `%NN` | `%20` | `%D0%90` (UTF-8) |
| JSON, JavaScript | `\uNNNN` | `\u0020` | `\u0410` |
| HTML/XML числовой | `&#xNN;` или `&#DD;` | `&#x20;` или `&#32;` | `&#x410;` или `&#1040;` |
| HTML entities | `&name;` | `&nbsp;` (неразрывный) | — |
| Python Unicode | `\uNNNN` или `\UNNNNNNNN` | `\u0020` | `\u0410` |

### Hex-экранирование (\xNN)

Самый низкоуровневый формат — представление **одного байта** его hex-кодом:

```bash
# Создание файла с пробелами в имени
$ touch $'file\x20with\x20spaces.txt'
$ ls
file with spaces.txt

# Вывод непечатных символов
$ echo -e "Hello\x00World"  # NUL-байт между словами
$ echo -e "Tab:\x09End"     # 0x09 = Tab
$ echo -e "Line1\x0ALine2"  # 0x0A = LF (перевод строки)
```

**В Python:**

```python
# Байтовые строки
data = b'\x48\x65\x6c\x6c\x6f'  # b'Hello'
print(data.decode('ascii'))  # Hello

# Unicode-строки — \x только для 0x00-0xFF
print('\x48\x65\x6c\x6c\x6f')  # Hello
print('\x00')  # NUL
```

### URL-кодирование (percent-encoding)

В URL многие символы запрещены. Их заменяют на `%XX`:

```bash
# Пробел в URL
https://example.com/search?q=hello%20world

# Кириллица (UTF-8 байты)
https://example.com/страница
# → https://example.com/%D1%81%D1%82%D1%80%D0%B0%D0%BD%D0%B8%D1%86%D0%B0
```

```python
import urllib.parse

# Кодирование
print(urllib.parse.quote("hello world"))  # hello%20world
print(urllib.parse.quote("привет"))       # %D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82

# Декодирование  
print(urllib.parse.unquote("hello%20world"))  # hello world
```

### JSON-экранирование (\uNNNN)

JSON требует экранирования управляющих символов и может экранировать любые Unicode:

```python
import json

# Автоматическое экранирование
data = {"text": "Line1\nLine2", "emoji": "😀"}
print(json.dumps(data))
# {"text": "Line1\nLine2", "emoji": "\ud83d\ude00"}

# ensure_ascii=False — без экранирования Unicode
print(json.dumps(data, ensure_ascii=False))
# {"text": "Line1\nLine2", "emoji": "😀"}
```

### systemd-escape — практический пример

В systemd имена юнитов (`.mount`, `.service`) строятся из путей, где `/` → `-`. Но как быть с дефисом в имени?

```bash
# Проблема: путь /mnt/my-data
# Простая замена / на - даст: mnt-my-data
# Как отличить от /mnt/my/data → mnt-my-data ?

# Решение: дефис кодируется как \x2d
$ systemd-escape "my-data"
my\x2ddata

$ systemd-escape --path /mnt/my-data
mnt-my\x2ddata

$ systemd-escape --path --suffix=mount /mnt/my-data
mnt-my\x2ddata.mount

# Пробелы тоже экранируются
$ systemd-escape "hello world"
hello\x20world

# Обратное преобразование
$ systemd-escape --unescape 'my\x2ddata'
my-data
```

### Инструменты экранирования

| Инструмент | Формат | Применение |
|------------|--------|------------|
| `printf %q` | Shell quoting | Безопасная передача аргументов |
| `systemd-escape` | `\xNN` | Имена systemd-юнитов |
| `jq -R` / `jq -r` | JSON | Кодирование/декодирование JSON-строк |
| `python -c "import urllib.parse; ..."` | `%XX` | URL |
| `xxd -p` / `xxd -r -p` | Чистый hex | Бинарные данные |
| `base64` / `base64 -d` | Base64 | Бинарные данные в текст |
| `uuencode` / `uudecode` | UUencode | Старый формат (email) |

```bash
# printf %q — shell-safe строка
$ printf %q "hello world; rm -rf /"
hello\ world\;\ rm\ -rf\ /

# xxd — hex dump и обратно
$ echo "Hi" | xxd -p
48690a
$ echo "48690a" | xxd -r -p
Hi

# base64
$ echo "Hello" | base64
SGVsbG8K
$ echo "SGVsbG8K" | base64 -d
Hello
```

---

## 12.7 Практическая работа с ASCII

### Просмотр ASCII-кодов

```bash
# Hexdump
$ echo "Hello" | hexdump -C
00000000  48 65 6c 6c 6f 0a                                 |Hello.|
          ^  ^  ^  ^  ^  ^
          H  e  l  l  o  \n

# xxd
$ echo "Hello" | xxd
00000000: 4865 6c6c 6f0a                           Hello.

# od (octal dump)
$ echo "Hello" | od -c
0000000    H   e   l   l   o  \n
```

### Python: работа с ASCII

```python
# Код символа
print(ord('A'))  # 65
print(ord('a'))  # 97
print(ord('0'))  # 48

# Символ по коду
print(chr(65))   # 'A'
print(chr(97))   # 'a'
print(chr(48))   # '0'

# Полная таблица ASCII
print("Печатные символы ASCII:")
for row in range(2, 8):
    for col in range(16):
        code = row * 16 + col
        if 32 <= code < 127:
            print(f"{code:3d}:{chr(code)}", end=" ")
    print()

# Проверка ASCII
def is_ascii(text):
    return all(ord(c) < 128 for c in text)

print(is_ascii("Hello"))    # True
print(is_ascii("Привет"))   # False
```

### Конвертация строк в hex

```python
# Строка → hex
text = "Hello"
hex_str = text.encode('ascii').hex()
print(hex_str)  # '48656c6c6f'

# Hex → строка
hex_str = "48656c6c6f"
text = bytes.fromhex(hex_str).decode('ascii')
print(text)  # 'Hello'

# С пробелами
hex_with_spaces = ' '.join(f'{ord(c):02x}' for c in "Hello")
print(hex_with_spaces)  # '48 65 6c 6c 6f'
```

### ROT13 — простой шифр

```python
# ROT13: сдвиг букв на 13 позиций
import codecs

text = "Hello World"
encoded = codecs.encode(text, 'rot_13')
print(encoded)  # 'Uryyb Jbeyq'

# Двойное применение возвращает оригинал
decoded = codecs.encode(encoded, 'rot_13')
print(decoded)  # 'Hello World'

# Ручная реализация
def rot13(text):
    result = []
    for c in text:
        if 'A' <= c <= 'Z':
            result.append(chr((ord(c) - ord('A') + 13) % 26 + ord('A')))
        elif 'a' <= c <= 'z':
            result.append(chr((ord(c) - ord('a') + 13) % 26 + ord('a')))
        else:
            result.append(c)
    return ''.join(result)
```

---

## 12.8 Ограничения ASCII

### Только 128 символов

```
128 символов достаточно для:
✅ Латинского алфавита (a-z, A-Z)
✅ Цифр (0-9)
✅ Базовой пунктуации
✅ Управляющих символов

128 символов НЕ хватает для:
❌ Кириллицы (АБВ...Я)
❌ Диакритики (àéîõü)
❌ Иероглифов (中文日本語)
❌ Греческого (αβγ)
❌ Арабского (العربية)
❌ Эмодзи (😀🎉)
```

### Последствия

Ограничения ASCII привели к:

1. **8-битным кодировкам** — расширение до 256 символов
2. **Code pages** — разные таблицы для разных языков  
3. **Хаосу совместимости** — один файл, разные интерпретации
4. **Появлению Unicode** — единый стандарт для всех языков

---

## Резюме

### Ключевые факты об ASCII

| Характеристика | Значение |
|----------------|----------|
| Год создания | 1963 (стандарт 1967) |
| Бит на символ | 7 |
| Количество символов | 128 (0x00-0x7F) |
| Управляющие символы | 0x00-0x1F, 0x7F |
| Печатные символы | 0x20-0x7E |
| Цифры | 0x30-0x39 |
| Заглавные буквы | 0x41-0x5A |
| Строчные буквы | 0x61-0x7A |

### Команды

| Команда | Назначение |
|---------|-----------|
| `hexdump -C file` | Просмотр байтов файла |
| `xxd file` | Hex-дамп |
| `cat -A file` | Показать непечатные символы |
| `dos2unix file` | CRLF → LF |
| `unix2dos file` | LF → CRLF |
| `file file.txt` | Определить тип файла |

### Почему ASCII важен

1. **Совместимость** — ASCII-символы одинаковы во всех кодировках
2. **UTF-8** — полностью совместим с ASCII (первые 128 символов)
3. **Протоколы** — HTTP, SMTP, многие другие основаны на ASCII
4. **Исходный код** — ключевые слова языков программирования в ASCII


??? question "Упражнения"
    **Задание 1.** Напишите однострочник, который выводит полную таблицу ASCII (коды 32–126) с символами: `python3 -c "..."`.
    
    **Задание 2.** Создайте файл с окончаниями строк CRLF и LF. Покажите разницу через `xxd`. Конвертируйте CRLF→LF с помощью `tr -d '\r'`.
    
    **Задание 3.** Какие управляющие символы ASCII вы используете ежедневно, не задумываясь? (Подсказка: Tab, Enter, Backspace — найдите их коды в таблице.)

!!! tip "Следующая глава"
    ASCII — фундамент, но 128 символов недостаточно для мира. В следующей главе изучим **8-битные кодировки** и проблемы, которые они создали → [Вавилонская башня кодировок](13-encodings-babel.md)
